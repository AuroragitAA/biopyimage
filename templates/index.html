<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIOIMAGIN Focused - Professional Wolffia Analysis</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 40px;
            padding: 25px;
            border-radius: 10px;
            background: #f8f9fa;
            border-left: 5px solid #007bff;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .upload-area {
            border: 3px dashed #007bff;
            border-radius: 10px;
            padding: 50px;
            text-align: center;
            background: white;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #0056b3;
            background: #f8f9fa;
        }

        .upload-area.dragover {
            border-color: #28a745;
            background: #d4edda;
        }

        .file-input {
            display: none;
        }

        .upload-text {
            font-size: 1.2em;
            color: #6c757d;
            margin-bottom: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
        }

        .btn-primary {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
        }

        .options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .option-group {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .option-group h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            background: #f8f9fa;
            transition: all 0.3s ease;
        }

        .checkbox-container:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .checkbox-container input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #007bff;
        }

        .status-indicator {
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .files-list {
            margin-top: 20px;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            color: #2c3e50;
        }

        .file-status {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #28a745);
            width: 0%;
            transition: width 0.3s ease;
        }

        .results-container {
            margin-top: 30px;
        }

        .result-item {
            background: white;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .result-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
        }

        /* Method Panel System */
        .method-panels-container {
            margin: 30px 0;
            border: 2px solid #e3f2fd;
            border-radius: 15px;
            overflow: hidden;
        }

        .method-tabs {
            display: flex;
            background: #515774;
            border-bottom: 2px solid #e3f2fd;
        }

        .method-tab {
            flex: 1;
            padding: 15px 20px;
            background: #48486d;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            border-right: 1px solid #ddd;
        }

        .method-tab:last-child {
            border-right: none;
        }

        .method-tab.active {
            background: #2196f3;
            color: white;
        }

        .method-tab:hover:not(.active) {
            background: #e3f2fd;
        }

        .method-panel {
            display: none;
            padding: 30px;
            background: white;
        }

        .method-panel.active {
            display: block;
        }

        .method-result-header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .method-result-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .method-result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .method-stat {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }

        .method-stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #2196f3;
        }

        .method-stat-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        .method-visualization {
            text-align: center;
            margin: 20px 0;
        }

        .method-visualization img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .detection-method {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            color: white;
        }

        .method-ai {
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .method-classical {
            background: linear-gradient(135deg, #ffc107, #e0a800);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .metric-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .metric-label {
            color: #6c757d;
            font-size: 0.9em;
        }

        .biomass-card {
            background: linear-gradient(135deg, #28a745, #20c997) !important;
            color: white;
        }

        .biomass-card .metric-value {
            color: white;
        }

        .biomass-card .metric-label {
            color: rgba(255,255,255,0.9);
        }

        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .visualization-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .visualization-item h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .visualization-item img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .export-section {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .temporal-section {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            border-left-color: #ff9800;
        }

        .batch-progress {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .health-indicator {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            color: white;
            margin: 0 5px;
        }

        .health-excellent { background: #28a745; }
        .health-good { background: #6f42c1; }
        .health-moderate { background: #ffc107; color: #000; }
        .health-poor { background: #dc3545; }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .main-content {
                padding: 20px;
            }

            .options {
                grid-template-columns: 1fr;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }

            .visualization-grid {
                grid-template-columns: 1fr;
            }

            .export-buttons {
                flex-direction: column;
            }
        }

                /* Essential overrides only - main styles come from external CSS */
        .file-input { display: none; }
        .hidden { display: none !important; }
        
        /* Essential styling for pipeline functionality */
        .pipeline-container { margin: 20px 0; }
        .pipeline-content.expanded { max-height: 3000px !important; }
        
        /* Essential responsive overrides */
        @media (max-width: 768px) {
            .container { margin: 10px; }
            .options { grid-template-columns: 1fr; }
            .metrics-grid { grid-template-columns: 1fr; }
            .visualization-grid { grid-template-columns: 1fr; }
            .export-buttons { flex-direction: column; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ BIOIMAGIN Focused</h1>
            <p>Professional Wolffia Arrhiza Analysis & Quantification System</p>
        </div>

        <div class="main-content">
            <!-- Image Upload Section -->
            <div class="section">
                <h2>üì∏ Image Upload & Analysis Configuration</h2>
                
                <div class="upload-area" id="uploadArea">
                    <div class="upload-text">
                        <strong>Drop images here or click to select</strong><br>
                        Supports: PNG, JPG, JPEG, BMP, TIFF (Max 100MB each)
                    </div>
                    <input type="file" id="fileInput" class="file-input" multiple accept=".png,.jpg,.jpeg,.bmp,.tiff,.tif,.jfif">
                    <button class="btn" onclick="document.getElementById('fileInput').click()">
                        üìÅ Select Images
                    </button>
                </div>

                <div class="options">
                    <!-- AI Detection Options -->
                    <div class="option-group">
                        <h3>üß† AI Detection</h3>
                        <div class="checkbox-container">
                            <input type="checkbox" id="useCellDetection" checked>
                            <label for="useCellDetection"><strong>Use CellDetection AI</strong> (Recommended)</label>
                        </div>
                        <div id="celldetectionStatus" class="status-indicator" style="display: none;">
                            Checking AI model status...
                        </div>
                        
                        <div class="checkbox-container">
                            <input type="checkbox" id="useTophat">
                            <label for="useTophat"><strong>Use Tophat AI Model</strong> (if trained)</label>
                        </div>
                        <div id="tophatStatus" class="status-indicator" style="display: none;">
                            Checking Tophat model status...
                        </div>
                        
                        <div class="checkbox-container">
                            <input type="checkbox" id="useWolffiaCNN" checked>
                            <label for="useWolffiaCNN"><strong>Use Wolffia CNN Model</strong> (Enhanced Detection)</label>
                        </div>
                        <div id="wolffiaCNNStatus" class="status-indicator" style="display: none;">
                            Checking Wolffia CNN model status...
                        </div>
                        
                        <!-- Model Refresh Button -->
                        <div style="margin-top: 15px; text-align: center;">
                            <button class="btn" id="refreshModelsBtn" onclick="refreshModelStatus()" style="background: #28a745; color: white; font-size: 0.9em;">
                                üîÑ Refresh AI Models
                            </button>
                            <p style="font-size: 0.8em; color: #6c757d; margin-top: 5px;">
                                Click after training new models
                            </p>
                        </div>
                    </div>
                    
                    <!-- Temporal Analysis Options -->
                    <div class="option-group">
                        <h3>‚è±Ô∏è Temporal Analysis</h3>
                        <div class="checkbox-container">
                            <input type="checkbox" id="enableTemporal">
                            <label for="enableTemporal"><strong>Enable Time-Series Analysis</strong></label>
                        </div>
                        <p style="font-size: 0.9em; color: #6c757d; margin-top: 10px;">
                            Track changes over time when uploading multiple images from different time points
                        </p>
                    </div>
                    
                    <!-- Analysis Controls -->
                    <div class="option-group">
                        <h3>üéØ Analysis Control</h3>
                        <button class="btn btn-success" id="analyzeBtn" onclick="startAnalysis()" disabled>
                            üß¨ Start Individual Analysis
                        </button>
                        <button class="btn btn-primary" id="batchAnalyzeBtn" onclick="startBatchAnalysis()" disabled>
                            üìä Start Batch Analysis
                        </button>
                    </div>
                </div>

                <div class="files-list" id="filesList"></div>
            </div>

            <!-- Batch Progress Section -->
            <div id="batchProgressSection" style="display: none;">
                <div class="batch-progress">
                    <h3>üìä Batch Analysis Progress</h3>
                    <div class="progress-bar" style="margin: 20px auto; max-width: 500px;">
                        <div class="progress-fill" id="batchProgressFill"></div>
                    </div>
                    <p id="batchProgressText">Preparing analysis...</p>
                </div>
            </div>

            <!-- Results Section -->
            <div class="section" id="resultsSection" style="display: none;">
                <h2>üìä Analysis Results</h2>
                <div class="results-container" id="resultsContainer"></div>
            </div>

            <!-- Add this section after the main stats-grid div -->
<div class="enhanced-analysis-section" style="margin: 30px 0;">
    <h3>üî¨ Enhanced Wolffia Analysis</h3>
    
    <!-- Biomass Analysis Section -->
    <div class="biomass-analysis" style="background: linear-gradient(145deg, #E8F5E8, #F1F8E9); padding: 20px; border-radius: 12px; margin: 20px 0;">
        <h4>‚öñÔ∏è Biomass Analysis</h4>
        <div class="biomass-metrics" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
            <div class="biomass-metric">
                <div class="metric-value" style="font-size: 1.8em; font-weight: bold; color: #2E7D32;" id="total-biomass">0.000 mg</div>
                <div class="metric-label">Total Biomass</div>
            </div>
            <div class="biomass-metric">
                <div class="metric-value" style="font-size: 1.8em; font-weight: bold; color: #2E7D32;" id="avg-biomass">0.000 mg</div>
                <div class="metric-label">Average per Cell</div>
            </div>
            <div class="biomass-metric">
                <div class="metric-value" style="font-size: 1.8em; font-weight: bold; color: #2E7D32;" id="biomass-density">0.000 mg/mm¬≤</div>
                <div class="metric-label">Biomass Density</div>
            </div>
        </div>
    </div>
    
    <!-- Color Analysis Section -->
    <div class="color-analysis" style="background: linear-gradient(145deg, #E3F2FD, #E8F5E8); padding: 20px; border-radius: 12px; margin: 20px 0;">
        <h4>üü¢ Green Content Analysis</h4>
        <div class="color-metrics" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
            <div class="color-metric">
                <div class="metric-value" style="font-size: 1.8em; font-weight: bold; color: #4CAF50;" id="green-percentage">0.0%</div>
                <div class="metric-label">Average Green Content</div>
            </div>
            <div class="color-metric">
                <div class="metric-value" style="font-size: 1.8em; font-weight: bold; color: #4CAF50;" id="green-cells-count">0</div>
                <div class="metric-label">Healthy Green Cells</div>
            </div>
            <div class="color-metric">
                <div class="metric-value" style="font-size: 1.8em; font-weight: bold; color: #4CAF50;" id="chlorophyll-estimate">0.0</div>
                <div class="metric-label">Chlorophyll Index</div>
            </div>
        </div>
    </div>
    
    <!-- Morphological Analysis Section -->
    <div class="morphological-analysis" style="background: linear-gradient(145deg, #FFF3E0, #F3E5F5); padding: 20px; border-radius: 12px; margin: 20px 0;">
        <h4>üìè Morphological Distribution</h4>
        <div class="size-distribution" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
            <div class="size-category">
                <div class="metric-value" style="font-size: 1.5em; font-weight: bold; color: #FF9800;" id="small-cells">0</div>
                <div class="metric-label">Small Cells (<100 Œºm¬≤)</div>
            </div>
            <div class="size-category">
                <div class="metric-value" style="font-size: 1.5em; font-weight: bold; color: #FF9800;" id="medium-cells">0</div>
                <div class="metric-label">Medium Cells (100-300 Œºm¬≤)</div>
            </div>
            <div class="size-category">
                <div class="metric-value" style="font-size: 1.5em; font-weight: bold; color: #FF9800;" id="large-cells">0</div>
                <div class="metric-label">Large Cells (>300 Œºm¬≤)</div>
            </div>
            <div class="size-category">
                <div class="metric-value" style="font-size: 1.5em; font-weight: bold; color: #9C27B0;" id="avg-circularity">0.00</div>
                <div class="metric-label">Average Circularity</div>
            </div>
        </div>
    </div>
</div>

<!-- Enhanced Pipeline Visualization Section -->
<div class="pipeline-enhanced" style="margin: 30px 0;">
    <h4>üîÑ Simplified Watershed Pipeline (8 Steps)</h4>
    <div class="pipeline-preview" id="pipeline-preview" style="background: #f8f9fa; padding: 20px; border-radius: 12px; text-align: center;">
        <p style="color: #666; margin: 20px 0;">Pipeline visualization will appear here after analysis</p>
    </div>
</div>

            <!-- Tophat Training Section -->
            <div class="section" style="background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); border-left-color: #ffc107;">
                <h2>üéØ Tophat AI Training</h2>
                <p>Train the AI to better detect cells by correcting automatic detections</p>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">
                    <div style="background: white; padding: 20px; border-radius: 10px; text-align: center;">
                        <div style="background: #ffc107; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 20px; font-weight: bold;">1</div>
                        <h4>Upload Images</h4>
                        <p>Upload multiple images for training</p>
                    </div>
                    <div style="background: white; padding: 20px; border-radius: 10px; text-align: center;">
                        <div style="background: #ffc107; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 20px; font-weight: bold;">2</div>
                        <h4>Review Detections</h4>
                        <p>Mark correct and incorrect cell detections</p>
                    </div>
                    <div style="background: white; padding: 20px; border-radius: 10px; text-align: center;">
                        <div style="background: #ffc107; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 20px; font-weight: bold;">3</div>
                        <h4>Train Model</h4>
                        <p>AI learns from your corrections</p>
                    </div>
                </div>

                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-warning" id="startTrainingBtn" onclick="startTophatTraining()" disabled>
                        üß† Start Training Session
                    </button>
                </div>

                <div id="trainingContainer" style="display: none; margin-top: 20px;">
                    <!-- Training interface will be loaded here -->
                </div>
            </div>

            <!-- System Status Section -->
            <div class="section" style="background: linear-gradient(135deg, #f0f8ff, #e6f3ff);">
                <h2>üîß System Status</h2>
                <div id="systemStatus">
                    <p>Loading system status...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let uploadedFiles = [];
        let analysisResults = {};
        let batchAnalysisId = null;

        // Initialize system
        window.addEventListener('load', () => {
            checkSystemStatus();
        });

        function checkSystemStatus() {
            // Check CellDetection status
            fetch('/api/celldetection/status')
                .then(response => response.json())
                .then(data => {
                    const statusDiv = document.getElementById('celldetectionStatus');
                    const checkbox = document.getElementById('useCellDetection');
                    
                    if (data.success && data.status.available && data.status.model_loaded) {
                        statusDiv.innerHTML = `‚úÖ CellDetection AI ready (${data.status.device.toUpperCase()})`;
                        statusDiv.className = 'status-indicator status-success';
                        checkbox.disabled = false;
                    } else if (data.success && data.status.available && !data.status.model_loaded) {
                        statusDiv.innerHTML = '‚ö†Ô∏è CellDetection available but model not loaded';
                        statusDiv.className = 'status-indicator status-warning';
                        checkbox.disabled = false;
                    } else {
                        statusDiv.innerHTML = '‚ùå CellDetection not available';
                        statusDiv.className = 'status-indicator status-error';
                        checkbox.disabled = true;
                        checkbox.checked = false;
                    }
                    statusDiv.style.display = 'block';
                })
                .catch(error => {
                    console.error('Error checking CellDetection status:', error);
                });

            // Check Tophat status
            fetch('/api/tophat/model_status')
                .then(response => response.json())
                .then(data => {
                    const statusDiv = document.getElementById('tophatStatus');
                    const checkbox = document.getElementById('useTophat');
                    
                    if (data.model_available) {
                        statusDiv.innerHTML = 'Tophat AI model is available';
                        statusDiv.className = 'status-indicator status-success';
                        checkbox.disabled = false;
                    } else {
                        statusDiv.innerHTML = '‚ö†Ô∏è No Tophat model trained yet. Use training section below.';
                        statusDiv.className = 'status-indicator status-warning';
                        checkbox.disabled = true;
                        checkbox.checked = false;
                    }
                    statusDiv.style.display = 'block';
                })
                .catch(error => {
                    console.error('Error checking Tophat status:', error);
                });

            // Check Wolffia CNN status
            fetch('/api/health')
                .then(response => response.json())
                .then(data => {
                    const statusDiv = document.getElementById('wolffiaCNNStatus');
                    const checkbox = document.getElementById('useWolffiaCNN');
                    
                    if (data.ai_status && data.ai_status.wolffia_cnn_available) {
                        statusDiv.innerHTML = 'Wolffia CNN model is ready for enhanced detection';
                        statusDiv.className = 'status-indicator status-success';
                        checkbox.disabled = false;
                    } else {
                        statusDiv.innerHTML = '‚ö†Ô∏è Wolffia CNN model not trained yet. Run: python train_wolffia_cnn.py';
                        statusDiv.className = 'status-indicator status-warning';
                        checkbox.disabled = true;
                        checkbox.checked = false;
                    }
                    statusDiv.style.display = 'block';
                })
                .catch(error => {
                    console.error('Error checking Wolffia CNN status:', error);
                    const statusDiv = document.getElementById('wolffiaCNNStatus');
                    statusDiv.innerHTML = '‚ùå Could not check CNN model status';
                    statusDiv.className = 'status-indicator status-error';
                    statusDiv.style.display = 'block';
                });

            // Update system status display
            fetch('/api/health')
                .then(response => response.json())
                .then(data => {
                    const statusDiv = document.getElementById('systemStatus');
                    statusDiv.innerHTML = `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div>
                                <strong>System Status:</strong><br>
                                <span style="color: #28a745;">‚óè</span> ${data.status.toUpperCase()}
                            </div>
                            <div>
                                <strong>Version:</strong><br>
                                ${data.version}
                            </div>
                            <div>
                                <strong>Features:</strong><br>
                                ${data.features.length} modules active
                            </div>
                        </div>
                    `;
                })
                .catch(error => {
                    console.error('Error checking system health:', error);
                });
        }

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files);
            handleFiles(files);
        });

        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            handleFiles(files);
        });

        function handleFiles(files) {
            const validFiles = files.filter(file => {
                const validTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/bmp', 'image/tiff'];
                return validTypes.includes(file.type) && file.size <= 100 * 1024 * 1024;
            });

            if (validFiles.length === 0) {
                alert('No valid image files selected. Please select PNG, JPG, BMP, or TIFF files under 100MB.');
                return;
            }

            // Upload files
            const formData = new FormData();
            validFiles.forEach(file => formData.append('files', file));
            formData.append('use_celldetection', document.getElementById('useCellDetection').checked);
            formData.append('enable_temporal', document.getElementById('enableTemporal').checked);

            fetch('/api/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    uploadedFiles = data.files;
                    displayFiles();
                    document.getElementById('analyzeBtn').disabled = false;
                    document.getElementById('batchAnalyzeBtn').disabled = false;
                    document.getElementById('startTrainingBtn').disabled = false;
                    
                    if (data.temporal_analysis_enabled) {
                        alert(`‚úÖ ${data.files.length} files uploaded with temporal analysis enabled!`);
                    }
                } else {
                    alert('Upload failed: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Upload error:', error);
                alert('Upload failed. Please try again.');
            });
        }

        function displayFiles() {
            const filesList = document.getElementById('filesList');
            filesList.innerHTML = '';

            if (uploadedFiles.length === 0) return;

            const filesHeader = document.createElement('h3');
            filesHeader.textContent = `üìÅ Uploaded Files (${uploadedFiles.length})`;
            filesHeader.style.color = '#2c3e50';
            filesHeader.style.marginBottom = '15px';
            filesList.appendChild(filesHeader);

            uploadedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div class="file-info">
                        <div class="file-name">
                            ${index + 1}. ${file.filename}
                            ${file.timestamp ? `<span style="color: #007bff; font-size: 0.8em;">[${file.timestamp}]</span>` : ''}
                        </div>
                        <div class="file-status" id="status-${file.id}">Ready for analysis</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-${file.id}"></div>
                        </div>
                    </div>
                `;
                filesList.appendChild(fileItem);
            });
        }

        function startAnalysis() {
            if (uploadedFiles.length === 0) {
                alert('Please upload images first');
                return;
            }

            document.getElementById('resultsSection').style.display = 'block';
            const resultsContainer = document.getElementById('resultsContainer');
            resultsContainer.innerHTML = '';

            // Add progress indicator
            const progressIndicator = document.createElement('div');
            progressIndicator.className = 'batch-progress';
            progressIndicator.id = 'overall-progress';
            progressIndicator.innerHTML = `
                <h4>üìä Analyzing ${uploadedFiles.length} images individually...</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="overall-progress-fill"></div>
                </div>
                <p>Processing: <span id="current-progress">0</span> / ${uploadedFiles.length} completed</p>
            `;
            resultsContainer.appendChild(progressIndicator);

            let completedAnalyses = 0;
            
            // Analyze each file individually
            uploadedFiles.forEach((file, index) => {
                setTimeout(() => {
                    analyzeFile(file, () => {
                        completedAnalyses++;
                        updateOverallProgress(completedAnalyses, uploadedFiles.length);
                        
                        if (completedAnalyses === uploadedFiles.length) {
                            setTimeout(() => {
                                const progressDiv = document.getElementById('overall-progress');
                                if (progressDiv) {
                                    progressDiv.innerHTML = `
                                        <h4>‚úÖ All individual analyses completed!</h4>
                                        <p>Successfully processed ${uploadedFiles.length} images.</p>
                                    `;
                                    progressDiv.className = 'batch-progress';
                                    progressDiv.style.background = '#d4edda';
                                }
                            }, 1000);
                        }
                    });
                }, index * 200);
            });
        }

        function startBatchAnalysis() {
            if (uploadedFiles.length === 0) {
                alert('Please upload images first');
                return;
            }

            const enableTemporal = document.getElementById('enableTemporal').checked;
            const useCellDetection = document.getElementById('useCellDetection').checked;
            const useWolffiaCNN = document.getElementById('useWolffiaCNN').checked;

            // Show batch progress section
            document.getElementById('batchProgressSection').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'block';

            // Start batch analysis
            fetch('/api/analyze_batch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    files: uploadedFiles,
                    use_celldetection: useCellDetection,
                    use_wolffia_cnn: useWolffiaCNN,
                    enable_temporal: enableTemporal
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    batchAnalysisId = data.batch_id;
                    pollBatchAnalysisStatus(data.batch_id);
                } else {
                    alert('Batch analysis failed: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Batch analysis error:', error);
                alert('Batch analysis failed');
            });
        }

        function pollBatchAnalysisStatus(batchId) {
            const poll = () => {
                fetch(`/api/status/${batchId}`)
                    .then(response => response.json())
                    .then(data => {
                        const progressFill = document.getElementById('batchProgressFill');
                        const progressText = document.getElementById('batchProgressText');
                        
                        if (progressFill) {
                            progressFill.style.width = data.progress + '%';
                        }
                        
                        if (data.status === 'completed') {
                            if (progressText) {
                                progressText.textContent = '‚úÖ Batch analysis completed!';
                            }
                            displayBatchResults(data.result);
                        } else if (data.status === 'error') {
                            if (progressText) {
                                progressText.textContent = '‚ùå Batch analysis failed: ' + data.error;
                            }
                        } else {
                            if (progressText) {
                                progressText.textContent = 'Processing batch analysis...';
                            }
                            setTimeout(poll, 2000);
                        }
                    })
                    .catch(error => {
                        console.error('Status check error:', error);
                    });
            };

            poll();
        }

        function analyzeFile(file, onComplete) {
            const statusElement = document.getElementById(`status-${file.id}`);
            const progressElement = document.getElementById(`progress-${file.id}`);
            
            statusElement.textContent = 'Starting analysis...';
            progressElement.style.width = '10%';

            const useCellDetection = document.getElementById('useCellDetection').checked;
            const useTophat = document.getElementById('useTophat').checked;
            const useWolffiaCNN = document.getElementById('useWolffiaCNN').checked;

            fetch(`/api/analyze/${file.id}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    files: [file],
                    use_celldetection: useCellDetection,
                    use_tophat: useTophat,
                    use_wolffia_cnn: useWolffiaCNN
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    pollAnalysisStatus(file.id, file.filename, onComplete);
                } else {
                    statusElement.textContent = 'Analysis failed: ' + data.error;
                    statusElement.style.color = 'red';
                    if (onComplete) onComplete();
                }
            })
            .catch(error => {
                console.error('Analysis error:', error);
                statusElement.textContent = 'Analysis failed';
                statusElement.style.color = 'red';
                if (onComplete) onComplete();
            });
        }

        function pollAnalysisStatus(analysisId, filename, onComplete) {
            const statusElement = document.getElementById(`status-${analysisId}`);
            const progressElement = document.getElementById(`progress-${analysisId}`);

            const poll = () => {
                fetch(`/api/status/${analysisId}`)
                    .then(response => response.json())
                    .then(data => {
                        // Fix: Use data.analysis structure from backend
                        const analysis = data.analysis || {};
                        const progress = analysis.progress || 0;
                        const status = analysis.status || 'unknown';
                        
                        progressElement.style.width = progress + '%';
                        
                        if (status === 'completed') {
                            statusElement.textContent = 'Analysis completed ‚úÖ';
                            statusElement.style.color = 'green';
                            progressElement.style.width = '100%';
                            displayResults(analysisId, filename, analysis.result);
                            if (onComplete) onComplete();
                        } else if (status === 'error') {
                            statusElement.textContent = 'Analysis failed: ' + (analysis.error || 'Unknown error');
                            statusElement.style.color = 'red';
                            if (onComplete) onComplete();
                        } else {
                            statusElement.textContent = 'Processing...';
                            setTimeout(poll, 1000);
                        }
                    })
                    .catch(error => {
                        console.error('Status check error:', error);
                        statusElement.textContent = 'Status check failed';
                        statusElement.style.color = 'red';
                        if (onComplete) onComplete();
                    });
            };

            poll();
        }

       // ‚úÖ Unified and Corrected displayResults function
function displayResults(analysisId, filename, result) {
    const resultsContainer = document.getElementById('resultsContainer');
    const resultItem = document.createElement('div');
    resultItem.className = 'result-item analysis-success';

    const detectionMethod = result?.detection_results?.detection_method || 'Unknown Detection';
    const pipelineSteps = result?.visualizations?.pipeline_steps || {};
    const methodResults = result.method_results || {};
    const hasMethodResults = Object.keys(methodResults).length > 0;

    // Always show header + pipeline ON TOP
    const headerHTML = `
        <div class="result-header">
            <div class="result-title">üìÑ ${filename}</div>
            <div class="detection-method">${detectionMethod}</div>
        </div>
    `;
    const pipelineHTML = createPipelineVisualization(pipelineSteps, detectionMethod);

    // Start with pipeline shown first
    resultItem.innerHTML = headerHTML + pipelineHTML;

    // ‚ö†Ô∏è Append method results or fallback legacy metrics
    if (hasMethodResults) {
        resultItem.innerHTML += renderMethodTabs(analysisId, methodResults, result.best_method);
    } else {
        resultItem.innerHTML += renderLegacyMetrics(analysisId, result);
    }

    // Add shared visualizations container
    const vizContainer = document.createElement('div');
    vizContainer.className = 'visualization-grid';
    vizContainer.id = `viz-${analysisId}`;
    resultItem.appendChild(vizContainer);

    resultsContainer.appendChild(resultItem);

    loadVisualizations(analysisId, result.visualizations || {});
    setupPipelineInteractions(analysisId);
    resultItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function renderMethodTabs(analysisId, methods, bestKey) {
    let tabs = '', panels = '';
    const methodKeys = Object.keys(methods);
    methodKeys.forEach((key, i) => {
        const m = methods[key];
        const isActive = i === 0 ? 'active' : '';
        const isBest = key === bestKey ? '‚≠ê' : '';

        tabs += `
            <button class="method-tab ${isActive}" onclick="switchMethodTab('${analysisId}', '${key}', this)">
                ${m.method_name} ${isBest}<br><small>${m.cells_detected} cells</small>
            </button>
        `;

        panels += `
            <div class="method-panel ${isActive}" id="${analysisId}-panel-${key}">
                <div class="method-result-header">
                    <div class="method-result-title">${m.method_name}</div>
                    <div style="color:#666">${m.cells_detected} cells detected</div>
                </div>
                <div class="method-result-stats">
                    <div class="method-stat"><div class="method-stat-value">${m.cells_detected}</div><div class="method-stat-label">Cells</div></div>
                    <div class="method-stat"><div class="method-stat-value">${m.total_area.toFixed(1)}</div><div class="method-stat-label">Total Area</div></div>
                    <div class="method-stat"><div class="method-stat-value">${m.average_area.toFixed(1)}</div><div class="method-stat-label">Avg Area</div></div>
                </div>
                ${m.visualization_b64 ? `<img src="data:image/png;base64,${m.visualization_b64}" class="method-visualization"/>` : `<div style='text-align:center;'>No visualization</div>`}
                <div style="text-align:center;margin-top:15px">
                    <button class="btn" onclick="exportMethodResults('${analysisId}', '${key}', 'csv')">üìä Export CSV</button>
                </div>
            </div>
        `;
    });

    return `
        <div class="method-panels-container">
            <div class="method-tabs">${tabs}</div>
            ${panels}
            <div style="background:#f8f9fa;padding:15px;margin-top:15px;border-radius:10px">
                <strong>Best Method:</strong> ${methods[bestKey]?.method_name || 'N/A'}
            </div>
        </div>
    `;
}

function renderLegacyMetrics(analysisId, result) {
    const d = result.detection_results || {};
    const q = result.quantitative_analysis || {};
    const b = q.biomass_analysis || {};
    const c = q.color_analysis || {};
    const h = q.health_assessment || {};
    const t = result.temporal_analysis || {};
    const visual = result.visualizations || {};
    const legend = visual.detection_legend || {};

    return `
        <div class="metrics-grid">
            <div class="metric-card"><div class="metric-value">${d.cells_detected || 0}</div><div class="metric-label">Cells</div></div>
            <div class="metric-card biomass-card"><div class="metric-value">${b.total_biomass_mg?.toFixed(3) || '0.000'}</div><div class="metric-label">Biomass</div></div>
            <div class="metric-card"><div class="metric-value">${c.green_cell_percentage?.toFixed(1) || '0.0'}%</div><div class="metric-label">Green Cells</div></div>
            <div class="metric-card"><div class="metric-value">${q.average_cell_area?.toFixed(1) || '0.0'}</div><div class="metric-label">Avg Area</div></div>
        </div>
        ${h.overall_health ? `<div style="text-align:center;margin:20px 0;"><span class="health-indicator health-${h.overall_health}">Health: ${h.overall_health.toUpperCase()}</span> <span style="margin-left:10px">Score: ${h.health_score?.toFixed(2) || '0.00'}/1.0</span></div>` : ''}
        ${t?.time_points > 1 ? `
        <div style="background:#fff3e0;padding:15px;margin:20px 0;border-radius:8px">
            <h4>‚è±Ô∏è Temporal Analysis</h4>
            <p>Time Points: ${t.time_points}</p>
            <p>Trend: ${t.temporal_trend?.replace('_',' ').toUpperCase() || 'Unknown'}</p>
        </div>` : ''}
    `;
}

        
        function displaySeparateMethodResults(resultItem, analysisId, filename, result) {
            const methodResults = result.method_results || {};
            const bestMethod = result.best_method || 'watershed';
            
            let tabsHtml = '';
            let panelsHtml = '';
            
            // Create tabs for each method
            Object.keys(methodResults).forEach((methodKey, index) => {
                const methodData = methodResults[methodKey];
                const isActive = index === 0 ? 'active' : '';
                const isBest = methodKey === bestMethod;
                
                tabsHtml += `
                    <button class="method-tab ${isActive}" onclick="switchMethodTab('${analysisId}', '${methodKey}', this)">
                        ${methodData.method_name}
                        ${isBest ? ' ‚≠ê' : ''}
                        <br><small>${methodData.cells_detected} cells</small>
                    </button>
                `;
                
                panelsHtml += `
                    <div class="method-panel ${isActive}" id="${analysisId}-panel-${methodKey}">
                        <div class="method-result-header">
                            <div class="method-result-title">${methodData.method_name}</div>
                            <div style="color: #666;">${methodData.cells_detected} cells detected</div>
                        </div>
                        
                        <div class="method-result-stats">
                            <div class="method-stat">
                                <div class="method-stat-value">${methodData.cells_detected}</div>
                                <div class="method-stat-label">Cells Detected</div>
                            </div>
                            <div class="method-stat">
                                <div class="method-stat-value">${methodData.total_area.toFixed(1)}</div>
                                <div class="method-stat-label">Total Area (px¬≤)</div>
                            </div>
                            <div class="method-stat">
                                <div class="method-stat-value">${methodData.average_area.toFixed(1)}</div>
                                <div class="method-stat-label">Avg Area (px¬≤)</div>
                            </div>
                        </div>
                        
                        ${methodData.visualization_b64 ? `
                            <div class="method-visualization">
                                <img src="data:image/png;base64,${methodData.visualization_b64}" 
                                     alt="${methodData.method_name} Results"
                                     style="max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                            </div>
                        ` : `
                            <div style="text-align: center; padding: 40px; color: #666; background: #f8f9fa; border-radius: 10px;">
                                <i>Visualization not available for this method</i>
                            </div>
                        `}
                        
                        <!-- Export for this method -->
                        <div style="text-align: center; margin-top: 20px;">
                            <button class="btn" onclick="exportMethodResults('${analysisId}', '${methodKey}', 'csv')">
                                üìä Export ${methodData.method_name} CSV
                            </button>
                        </div>
                    </div>
                `;
            });
            
            resultItem.innerHTML = `
                <div class="result-header">
                    <div class="result-title">üìÑ ${filename}</div>
                    <div style="color: #007bff; font-weight: bold;">
                    Multi-Method Analysis (${Object.keys(methodResults).length} methods)
                    </div>
                </div>
                
                <div class="method-panels-container">
                    <div style="text-align: center; padding: 20px; background: #e3f2fd; font-weight: bold; color: #1976d2;">
                        üî¨ Analysis Methods - Click tabs to compare results
                    </div>
                    <div class="method-tabs">
                        ${tabsHtml}
                    </div>
                    ${panelsHtml}
                </div>
                
                <!-- Overall Summary -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0;">
                    <h4>üìä Best Result Summary</h4>
                    <p><strong>Best Method:</strong> ${methodResults[bestMethod]?.method_name} (${methodResults[bestMethod]?.cells_detected} cells)</p>
                    <p><strong>Processing Time:</strong> ${result.processing_time?.toFixed(2) || '0.00'} seconds</p>
                    <p><strong>Methods Used:</strong> ${Object.values(methodResults).map(m => m.method_name).join(', ')}</p>
                </div>
            `;
        }
        
        function displayLegacyResults(resultItem, analysisId, filename, result) {
            // Original display logic for backward compatibility
            const detection = result.detection_results || {};
            const quantitative = result.quantitative_analysis || {};
            const biomass = quantitative.biomass_analysis || {};
            const color = quantitative.color_analysis || {};
            const health = quantitative.health_assessment || {};
            const visualizations = result.visualizations || {};
            
            // Determine detection method class for styling
            let methodClass = 'method-classical-slic';
            if (detection.detection_method) {
                if (detection.detection_method.includes('CellDetection AI')) {
                    methodClass = 'method-celldetection-ai';
                } else if (detection.detection_method.includes('watershed')) {
                    methodClass = 'method-advanced-watershed';
                } else if (detection.detection_method.includes('shape')) {
                    methodClass = 'method-shape-based';
                }
            }
            
            resultItem.innerHTML = `
                <div class="result-header">
                    <div class="result-title">üìÑ ${filename}</div>
                    <div class="detection-method-enhanced ${methodClass}">
                        ${detection.detection_method || 'Classical Detection'}
                    </div>
                </div>

                <!-- METHOD PANEL SYSTEM -->
                ${createMethodPanels(result)}
                
                <!-- ENHANCED EXPANDABLE PROCESSING PIPELINE VISUALIZATION -->
                ${createPipelineVisualization(pipelineSteps, detection.detection_method)}

                <!-- Detection Legend -->
                ${legend.total_cells ? `
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0; border-left: 4px solid #007bff;">
                    <h4 style="color: #2c3e50; margin-bottom: 15px;">üîç Detection Summary & Color Legend</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                        <div>
                            <strong>Enhanced Detection Results:</strong><br>
                            ‚Ä¢ Total Cells: ${legend.total_cells}<br>
                            ‚Ä¢ Total Biomass: ${legend.metrics?.total_biomass_mg?.toFixed(3) || '0.000'} mg<br>
                            ‚Ä¢ Avg Cell Area: ${legend.metrics?.average_cell_area?.toFixed(1) || '0.0'} pixels¬≤<br>
                            ‚Ä¢ Green Cells: ${legend.metrics?.green_cell_percentage?.toFixed(1) || '0.0'}%<br>
                            ‚Ä¢ Health Status: ${legend.metrics?.health_status?.charAt(0).toUpperCase() + legend.metrics?.health_status?.slice(1) || 'Unknown'}
                        </div>
                        <div>
                            <strong>Color Legend:</strong><br>
                            <div style="display: flex; align-items: center; margin: 5px 0;">
                                <div style="width: 20px; height: 20px; background: lime; border-radius: 50%; margin-right: 10px;"></div>
                                <span>High Biomass (${legend.color_coding?.high_biomass?.threshold || '>0.1 mg'}): ${legend.color_coding?.high_biomass?.count || 0} cells</span>
                            </div>
                            <div style="display: flex; align-items: center; margin: 5px 0;">
                                <div style="width: 20px; height: 20px; background: yellow; border-radius: 50%; margin-right: 10px;"></div>
                                <span>Medium Biomass (${legend.color_coding?.medium_biomass?.threshold || '0.05-0.1 mg'}): ${legend.color_coding?.medium_biomass?.count || 0} cells</span>
                            </div>
                            <div style="display: flex; align-items: center; margin: 5px 0;">
                                <div style="width: 20px; height: 20px; background: red; border-radius: 50%; margin-right: 10px;"></div>
                                <span>Low Biomass (${legend.color_coding?.low_biomass?.threshold || '<0.05 mg'}): ${legend.color_coding?.low_biomass?.count || 0} cells</span>
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- Key Metrics -->
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">${detection.cells_detected || 0}</div>
                        <div class="metric-label">Cells Detected</div>
                    </div>
                    <div class="metric-card biomass-card">
                        <div class="metric-value">${biomass.total_biomass_mg?.toFixed(3) || '0.000'}</div>
                        <div class="metric-label">Total Biomass (mg)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${color.green_cell_percentage?.toFixed(1) || '0.0'}%</div>
                        <div class="metric-label">Green Cells</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${quantitative.average_cell_area?.toFixed(1) || '0.0'}</div>
                        <div class="metric-label">Avg Area (pixels¬≤)</div>
                    </div>
                </div>

                <!-- Health Status -->
                ${health.overall_health ? `
                <div style="text-align: center; margin: 20px 0;">
                    <span class="health-indicator health-${health.overall_health}">
                        Population Health: ${health.overall_health.toUpperCase()}
                    </span>
                    <span style="margin-left: 15px; color: #6c757d;">
                        Score: ${health.health_score?.toFixed(2) || '0.00'}/1.0
                    </span>
                </div>
                ` : ''}

                <!-- Visualizations -->
                <div class="visualization-grid" id="viz-${analysisId}">
                    <!-- Visualizations will be loaded here -->
                </div>

                <!-- Temporal Analysis -->
                ${temporal && temporal.time_points > 1 ? `
                <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin: 20px 0;">
                    <h4>‚è±Ô∏è Temporal Analysis</h4>
                    <p><strong>Time Points:</strong> ${temporal.time_points}</p>
                    <p><strong>Trend:</strong> ${temporal.temporal_trend?.replace('_', ' ').toUpperCase() || 'Unknown'}</p>
                    ${temporal.growth_analysis ? `
                    <p><strong>Cell Count Change:</strong> ${temporal.growth_analysis.avg_cell_count_change_percent?.toFixed(1) || '0.0'}% average</p>
                    ` : ''}
                </div>
                ` : ''}

                <!-- Export Section -->
                <div class="export-section">
                    <h4 style="text-align: center; margin-bottom: 15px;">üì• Export Results</h4>
                    <div class="export-buttons">
                        <button class="btn" onclick="exportResults('${analysisId}', 'csv')">üìä Export CSV</button>
                        <button class="btn" onclick="exportResults('${analysisId}', 'excel')">üìà Export Excel</button>
                        <button class="btn" onclick="exportResults('${analysisId}', 'json')">üìÑ Export JSON</button>
                        <button class="btn btn-success" onclick="exportResults('${analysisId}', 'report')">üìã Full Report (ZIP)</button>
                    </div>
                </div>
            `;
            
            resultsContainer.appendChild(resultItem);
            
            // Load visualizations (excluding pipeline - handled separately)
            loadVisualizations(analysisId, visualizations);
            
            // Setup pipeline interactions
            setupPipelineInteractions(analysisId);
            
            resultItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function createMethodPanels(result) {
            // Check if we have detection results with multiple methods
            const detectionResults = result.detection_results || {};
            const cells = detectionResults.cells_data || [];
            const visualizations = result.visualizations || {};
            const methodComparison = visualizations.method_comparison;
            
            // If no method comparison data, don't show panels
            if (!methodComparison || typeof methodComparison !== 'object') {
                return '';
            }
            
            // Get available methods
            const methods = Object.keys(methodComparison);
            if (methods.length <= 1) {
                return ''; // Don't show panels for single method
            }
            
            // Generate unique ID for this result
            const panelId = 'method-panels-' + Math.random().toString(36).substr(2, 9);
            
            // Create method tabs
            let tabsHtml = '';
            let panelsHtml = '';
            
            methods.forEach((method, index) => {
                const methodData = methodComparison[method];
                const methodName = method.replace(/_/g, ' ');
                const isActive = index === 0 ? 'active' : '';
                
                // Tab
                tabsHtml += `
                    <button class="method-tab ${isActive}" onclick="switchMethodPanel('${panelId}', ${index})">
                        ${methodName}
                        <br><small>${methodData.cell_count || 0} cells</small>
                    </button>
                `;
                
                // Panel content
                panelsHtml += `
                    <div class="method-panel ${isActive}" id="${panelId}-panel-${index}">
                        <div class="method-result-header">
                            <div class="method-result-title">${methodName} Results</div>
                            <div style="color: #666;">Independent detection results for comparison</div>
                        </div>
                        
                        <div class="method-result-stats">
                            <div class="method-stat">
                                <div class="method-stat-value">${methodData.cell_count || 0}</div>
                                <div class="method-stat-label">Cells Detected</div>
                            </div>
                            <div class="method-stat">
                                <div class="method-stat-value">${methodData.total_area || 0}</div>
                                <div class="method-stat-label">Total Area (px¬≤)</div>
                            </div>
                            <div class="method-stat">
                                <div class="method-stat-value">${(methodData.avg_confidence || 0).toFixed(2)}</div>
                                <div class="method-stat-label">Avg Confidence</div>
                            </div>
                        </div>
                        
                        ${methodData.visualization ? `
                            <div class="method-visualization">
                                <img src="data:image/png;base64,${methodData.visualization}" 
                                     alt="${methodName} Detection Results"
                                     style="max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                            </div>
                        ` : `
                            <div style="text-align: center; padding: 40px; color: #666; background: #f8f9fa; border-radius: 10px;">
                                <i>Visualization not available for this method</i>
                            </div>
                        `}
                    </div>
                `;
            });
            
            return `
                <div class="method-panels-container">
                    <div style="text-align: center; padding: 20px; background: #e3f2fd; font-weight: bold; color: #1976d2;">
                        üî¨ Detection Method Comparison - Select a method to view its individual results
                    </div>
                    <div class="method-tabs">
                        ${tabsHtml}
                    </div>
                    ${panelsHtml}
                </div>
            `;
        }
        
        function switchMethodPanel(panelId, activeIndex) {
            // Hide all panels for this container
            const container = document.querySelector(`#${panelId.replace('method-panels-', '')}-panel-0`).closest('.method-panels-container');
            const tabs = container.querySelectorAll('.method-tab');
            const panels = container.querySelectorAll('.method-panel');
            
            // Remove active class from all tabs and panels
            tabs.forEach(tab => tab.classList.remove('active'));
            panels.forEach(panel => panel.classList.remove('active'));
            
            // Add active class to selected tab and panel
            tabs[activeIndex].classList.add('active');
            panels[activeIndex].classList.add('active');
        }

        function createPipelineVisualization(pipelineSteps, detectionMethod) {
            if (!pipelineSteps || !pipelineSteps.pipeline_overview) {
                return `
                <div class="pipeline-container">
                    <div class="pipeline-header">
                        <h4>üî¨ Processing Pipeline</h4>
                        <span style="color: #ffc107;">‚ö†Ô∏è Pipeline visualization not available</span>
                    </div>
                </div>
                `;
            }
            
            const stepDescriptions = pipelineSteps.step_descriptions || {};
            const individualSteps = pipelineSteps.individual_steps || {};
            const stepCount = pipelineSteps.step_count || 0;
            
            // Define pipeline steps with status
            const pipelineDefinition = [
                { key: 'original', name: 'Original Image', status: 'success', icon: 'üì∏' },
                { key: 'gray', name: 'Grayscale', status: 'success', icon: '‚ö´' },
                { key: 'denoised', name: 'Denoising', status: 'success', icon: 'üßπ' },
                { key: 'li_foreground', name: 'Li Thresholding', status: 'success', icon: 'üéØ' },
                { key: 'plate_removed', name: 'Plate Removal', status: 'success', icon: 'üóëÔ∏è' },
                { key: 'multi_otsu', name: 'Multi-Otsu', status: 'success', icon: 'üîß' },
                { key: 'combined', name: 'Mask Fusion', status: 'success', icon: 'üîÄ' },
                { key: 'opened', name: 'Morphological', status: 'success', icon: 'üîÑ' },
                { key: 'final', name: 'Final Segmentation', status: 'success', icon: '‚úÖ' },
                { key: 'detection_result', name: 'Cell Detection', status: detectionMethod?.includes('AI') ? 'success' : 'warning', icon: 'üß¨' }
            ];
            
            const uniqueId = `pipeline-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            return `
            <div class="pipeline-container" id="${uniqueId}">
                <div class="pipeline-header" onclick="togglePipeline(this)">
                    <h4>
                        <span class="step-indicator success"></span>
                        üî¨ Enhanced Detection Pipeline
                        <span style="font-size: 0.8em; font-weight: normal; margin-left: 10px;">
                            (${stepCount} processing steps completed)
                        </span>
                    </h4>
                    <span class="pipeline-toggle">‚ñº</span>
                </div>
                <div class="pipeline-content">
                    <!-- Steps Summary -->
                    <div class="pipeline-steps-summary">
                        ${pipelineDefinition.map(step => `
                            <div class="processing-step ${individualSteps[step.key] ? 'active' : 'inactive'}" 
                                onclick="showStepDetail('${step.key}', '${step.name}', '${stepDescriptions[step.key] || 'Processing step'}')">
                                <span class="step-indicator ${step.status}"></span>
                                ${step.icon} ${step.name}
                            </div>
                        `).join('')}
                    </div>
                    
                    <!-- Pipeline Overview -->
                    <div class="pipeline-overview">
                        <h5>üìä Complete Processing Pipeline</h5>
                        <p>Click the image below to see the full step-by-step processing pipeline:</p>
                        <img src="data:image/png;base64,${pipelineSteps.pipeline_overview}" 
                            alt="Complete Processing Pipeline"
                            onclick="openStepModal('Complete Processing Pipeline', 'data:image/png;base64,${pipelineSteps.pipeline_overview}', 'Full step-by-step processing pipeline showing each stage of the analysis')">
                    </div>
                    
                    <!-- Individual Steps -->
                    ${Object.keys(individualSteps).length > 0 ? `
                    <div class="individual-steps">
                        <h5>üîç Individual Processing Steps</h5>
                        <p>Click any step below to see detailed results and statistics:</p>
                        <div class="steps-grid">
                            ${pipelineDefinition.filter(step => individualSteps[step.key]).map(step => `
                                <div class="step-item" onclick="openStepModal('${step.name}', 'data:image/png;base64,${individualSteps[step.key]}', '${stepDescriptions[step.key] || 'Processing step details'}')">
                                    <img src="data:image/png;base64,${individualSteps[step.key]}" alt="${step.name}">
                                    <div class="step-item-info">
                                        <div class="step-item-title">${step.icon} ${step.name}</div>
                                        <div class="step-item-description">${stepDescriptions[step.key]?.substring(0, 80) || 'Click to view details'}...</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : ''}
                </div>
            </div>
            
            <!-- Modal for detailed step view -->
            <div id="stepModal" class="step-modal">
                <div class="step-modal-content">
                    <span class="step-modal-close" onclick="closeStepModal()">&times;</span>
                    <h3 id="stepModalTitle"></h3>
                    <p id="stepModalDescription"></p>
                    <img id="stepModalImage" src="" alt="">
                </div>
            </div>
            `;
        }
        function displayBatchResults(batchResult) {
            const resultsContainer = document.getElementById('resultsContainer');
            
            const batch = batchResult.batch_summary || {};
            const aggregate = batch.aggregate_statistics || {};
            
            const batchItem = document.createElement('div');
            batchItem.className = 'result-item';
            batchItem.style.background = 'linear-gradient(135deg, #e3f2fd, #bbdefb)';
            
            batchItem.innerHTML = `
                <div class="result-header">
                    <div class="result-title">üìä Batch Analysis Results</div>
                    <div style="color: #1976d2; font-weight: bold;">
                        ${batch.successful_analyses || 0}/${batch.total_files || 0} Files Processed
                    </div>
                </div>

                <!-- Aggregate Metrics -->
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">${aggregate.total_cells_detected || 0}</div>
                        <div class="metric-label">Total Cells Detected</div>
                    </div>
                    <div class="metric-card biomass-card">
                        <div class="metric-value">${aggregate.total_biomass_mg?.toFixed(3) || '0.000'}</div>
                        <div class="metric-label">Total Biomass (mg)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${aggregate.average_green_cell_percentage?.toFixed(1) || '0.0'}%</div>
                        <div class="metric-label">Avg Green Cells</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${batchResult.temporal_analysis ? 'Yes' : 'No'}</div>
                        <div class="metric-label">Temporal Analysis</div>
                    </div>
                </div>

                <!-- Health Distribution -->
                ${aggregate.health_distribution_aggregate ? `
                <div style="background: white; padding: 15px; border-radius: 8px; margin: 20px 0;">
                    <h4>üè• Population Health Distribution (Aggregate)</h4>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                        <span class="health-indicator health-excellent">Excellent: ${aggregate.health_distribution_aggregate.excellent || 0}</span>
                        <span class="health-indicator health-good">Good: ${aggregate.health_distribution_aggregate.good || 0}</span>
                        <span class="health-indicator health-moderate">Moderate: ${aggregate.health_distribution_aggregate.moderate || 0}</span>
                        <span class="health-indicator health-poor">Poor: ${aggregate.health_distribution_aggregate.poor || 0}</span>
                    </div>
                </div>
                ` : ''}

                <!-- Export Section -->
                <div class="export-section">
                    <h4 style="text-align: center; margin-bottom: 15px;">üì• Export Batch Results</h4>
                    <div class="export-buttons">
                        <button class="btn" onclick="exportResults('${batchAnalysisId}', 'csv')">üìä Export Batch CSV</button>
                        <button class="btn" onclick="exportResults('${batchAnalysisId}', 'excel')">üìà Export Batch Excel</button>
                        <button class="btn btn-success" onclick="exportResults('${batchAnalysisId}', 'report')">üìã Complete Batch Report</button>
                    </div>
                </div>
            `;
            
            resultsContainer.appendChild(batchItem);
            
            // Display individual results
            const individualResults = batchResult.individual_results || [];
            individualResults.forEach((result, index) => {
                if (result.success) {
                    const filename = uploadedFiles[index]?.filename || `Image_${index + 1}`;
                    displayResults(`batch_${index}`, filename, result);
                }
            });
        }

        function loadVisualizations(analysisId, visualizations) {
            const vizContainer = document.getElementById(`viz-${analysisId}`);
            if (!vizContainer) return;
            
            const vizConfig = {
                'biomass_chart': 'Biomass Analysis',
                'size_histogram': 'Size Distribution', 
                'color_analysis': 'Color Analysis',
                'temporal_analysis': 'Temporal Changes'
            };
            
            Object.entries(vizConfig).forEach(([key, title]) => {
                if (visualizations[key] && key !== 'pipeline_steps') {  // Exclude pipeline_steps (handled separately)
                    const vizItem = document.createElement('div');
                    vizItem.className = 'visualization-item';
                    
                    // Handle different visualization data formats
                    let imageSrc = '';
                    if (typeof visualizations[key] === 'string') {
                        imageSrc = `data:image/png;base64,${visualizations[key]}`;
                    } else if (visualizations[key] && visualizations[key].image) {
                        imageSrc = `data:image/png;base64,${visualizations[key].image}`;
                    }
                    
                    if (imageSrc) {
                        vizItem.innerHTML = `
                            <h4>${title}</h4>
                            <img src="${imageSrc}" 
                                alt="${title}"
                                loading="lazy">
                        `;
                        vizContainer.appendChild(vizItem);
                    }
                }
            });
        }



        function togglePipeline(header) {
            const container = header.parentElement;
            const content = container.querySelector('.pipeline-content');
            const toggle = header.querySelector('.pipeline-toggle');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                toggle.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                toggle.classList.add('expanded');
            }
        }

        function showStepDetail(stepKey, stepName, description) {
            console.log(`Showing details for ${stepName}: ${description}`);
            
            // Highlight the step with animation
            const stepElement = event.target;
            const originalTransform = stepElement.style.transform;
            stepElement.style.transform = 'scale(1.05)';
            stepElement.style.boxShadow = '0 4px 15px rgba(0,123,255,0.3)';
            
            setTimeout(() => {
                stepElement.style.transform = originalTransform;
                stepElement.style.boxShadow = '';
            }, 300);
        }

        function openStepModal(title, imageSrc, description) {
            const modal = document.getElementById('stepModal');
            const modalTitle = document.getElementById('stepModalTitle');
            const modalDescription = document.getElementById('stepModalDescription');
            const modalImage = document.getElementById('stepModalImage');
            
            modalTitle.textContent = title;
            modalDescription.textContent = description;
            modalImage.src = imageSrc;
            modalImage.alt = title;
            
            modal.style.display = 'block';
            
            // Close modal when clicking outside
            modal.onclick = function(event) {
                if (event.target === modal) {
                    closeStepModal();
                }
            }
        }

        function closeStepModal() {
            const modal = document.getElementById('stepModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function setupPipelineInteractions(analysisId) {
            // Add keyboard support for modal
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') {
                    closeStepModal();
                }
            });
        }

        // Auto-expand first pipeline when page loads
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                const firstPipeline = document.querySelector('.pipeline-header');
                if (firstPipeline) {
                    const content = firstPipeline.parentElement.querySelector('.pipeline-content');
                    if (content && !content.classList.contains('expanded')) {
                        togglePipeline(firstPipeline);
                    }
                }
            }, 1000);
        });

        // Prevent body scroll when modal is open
        function openStepModal(title, imageSrc, description) {
            const modal = document.getElementById('stepModal');
            const modalTitle = document.getElementById('stepModalTitle');
            const modalDescription = document.getElementById('stepModalDescription');
            const modalImage = document.getElementById('stepModalImage');
            
            modalTitle.textContent = title;
            modalDescription.textContent = description;
            modalImage.src = imageSrc;
            modalImage.alt = title;
            
            modal.style.display = 'block';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
            
            // Close modal when clicking outside
            modal.onclick = function(event) {
                if (event.target === modal) {
                    closeStepModal();
                }
            }
        }

        function closeStepModal() {
            const modal = document.getElementById('stepModal');
            if (modal) {
                modal.style.display = 'none';
                document.body.style.overflow = 'auto'; // Restore scrolling
            }
        }
        // Tophat Training Functions
        let currentTrainingSession = null;
        let drawingState = {};
        let annotations = {};

        function startTophatTraining() {
            if (uploadedFiles.length === 0) {
                alert('Please upload images first');
                return;
            }

            const trainingContainer = document.getElementById('trainingContainer');
            trainingContainer.style.display = 'block';
            trainingContainer.innerHTML = '<p>Starting training session...</p>';

            fetch('/api/tophat/start_training', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ files: uploadedFiles })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentTrainingSession = data.session;
                    displayTrainingInterface(data.session);
                } else {
                    trainingContainer.innerHTML = `<div class="status-indicator status-error">Training failed: ${data.error}</div>`;
                }
            })
            .catch(error => {
                console.error('Training start error:', error);
                trainingContainer.innerHTML = '<div class="status-indicator status-error">Failed to start training session</div>';
            });
        }

        function displayTrainingInterface(session) {
            const trainingContainer = document.getElementById('trainingContainer');
            
            let html = `
                <div class="status-indicator status-success">
                    Training session started with ${session.images_count} images
                </div>
                <p><strong>Instructions:</strong> For each image, you will draw directly on the image to mark correct cells (green) and false positives (red). This trains the AI to recognize cell patterns.</p>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0;">
                    <h4>üé® Drawing Instructions:</h4>
                    <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 20px; height: 20px; background: #28a745; border-radius: 50%;"></div>
                            <span><strong>Green:</strong> Draw around correct cells</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 20px; height: 20px; background: #dc3545; border-radius: 50%;"></div>
                            <span><strong>Red:</strong> Draw around false positives</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 20px; height: 20px; background: #007bff; border-radius: 50%;"></div>
                            <span><strong>Blue:</strong> Draw around missed cells</span>
                        </div>
                    </div>
                </div>
            `;

            session.images.forEach((image, index) => {
                html += `
                    <div class="result-item">
                        <h4>Image ${index + 1}: ${image.filename}</h4>
                        <p>Auto-detected cells: ${image.cells_count}</p>
                        <div style="text-align: center; margin: 20px 0;">
                            <button class="btn btn-warning" onclick="startDrawingAnnotation(${index})">
                                üé® Start Drawing Annotations
                            </button>
                        </div>
                        <div id="annotation-${index}" style="display: none;"></div>
                    </div>
                `;
            });

            html += `
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-success" onclick="finalizeTraining()">
                        üß† Finalize Training
                    </button>
                </div>
            `;

            trainingContainer.innerHTML = html;
        }

        function finalizeTraining() {
            if (!currentTrainingSession) {
                alert('No active training session');
                return;
            }

            fetch('/api/tophat/train_model', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: currentTrainingSession.id })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Tophat AI model trained successfully! You can now use it for analysis.');
                    checkSystemStatus(); // Refresh status
                } else {
                    alert('Training failed: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Training finalization error:', error);
                alert('Training finalization failed');
            });
        }

        function startDrawingAnnotation(imageIndex) {
            const annotationDiv = document.getElementById(`annotation-${imageIndex}`);
            annotationDiv.style.display = 'block';
            
            const image = currentTrainingSession.images[imageIndex];
            
            annotationDiv.innerHTML = `
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h4>üé® Drawing Tools</h4>
                        <p style="color: #666; font-size: 0.9em; margin: 10px 0;">
                            Select a tool below, then draw on the image to mark cells. 
                            Draw circles or outlines around cells you want to annotate.
                        </p>
                        <div style="display: flex; justify-content: center; gap: 15px; margin: 15px 0; flex-wrap: wrap;">
                            <button class="btn btn-success" onclick="setDrawingMode(${imageIndex}, 'correct')" id="correct-btn-${imageIndex}">
                                ‚úÖ Mark Correct Cells
                            </button>
                            <button class="btn" onclick="setDrawingMode(${imageIndex}, 'false_positive')" id="false-btn-${imageIndex}" style="background: #dc3545; color: white;">
                                ‚ùå Mark False Positives
                            </button>
                            <button class="btn btn-primary" onclick="setDrawingMode(${imageIndex}, 'missed')" id="missed-btn-${imageIndex}">
                                üîç Mark Missed Cells
                            </button>
                            <button class="btn" onclick="clearDrawing(${imageIndex})" style="background: #6c757d; color: white;">
                                üóëÔ∏è Clear All
                            </button>
                        </div>
                    </div>
                    
                    <div style="text-align: center; position: relative; display: inline-block; width: 100%;">
                        <div id="canvas-loading-${imageIndex}" style="
                            position: absolute; 
                            top: 50%; 
                            left: 50%; 
                            transform: translate(-50%, -50%);
                            background: rgba(255,255,255,0.9);
                            padding: 20px;
                            border-radius: 8px;
                            border: 2px solid #007bff;
                            z-index: 1000;
                        ">
                            <div style="font-size: 16px; color: #007bff; margin-bottom: 10px;">üì∏ Loading analysis result...</div>
                            <div style="width: 30px; height: 30px; border: 3px solid #f3f3f3; border-top: 3px solid #007bff; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                        </div>
                        <canvas id="drawing-canvas-${imageIndex}" 
                                style="border: 2px solid #007bff; border-radius: 8px; cursor: crosshair; max-width: 100%; display: block; margin: 0 auto;"
                                onmousedown="startDrawing(event, ${imageIndex})"
                                onmousemove="draw(event, ${imageIndex})"
                                onmouseup="stopDrawing(${imageIndex})"
                                onmouseleave="stopDrawing(${imageIndex})"
                                ontouchstart="handleTouch(event, ${imageIndex}, 'start')"
                                ontouchmove="handleTouch(event, ${imageIndex}, 'move')"
                                ontouchend="handleTouch(event, ${imageIndex}, 'end')">
                        </canvas>
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">
                            üí° <strong>Tip:</strong> You should see the original detection results with highlighted cells. 
                            Draw over correct detections in green, false positives in red, and missed cells in blue.
                        </p>
                        <button class="btn btn-warning" onclick="saveDrawingAnnotations(${imageIndex})">
                            üíæ Save Annotations for this Image
                        </button>
                    </div>
                </div>
            `;
            
            // Add CSS animation for loading spinner
            if (!document.getElementById('spinner-style')) {
                const style = document.createElement('style');
                style.id = 'spinner-style';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Load image onto canvas
            loadImageToCanvas(imageIndex, image);
        }

        function saveDrawingAnnotations(imageIndex) {
            if (!annotations[imageIndex]) {
                alert('No annotations to save');
                return;
            }
            
            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            if (!canvas) {
                alert('Canvas not found');
                return;
            }
            
            // Get the canvas image data
            const imageData = canvas.toDataURL('image/png');
            
            // Show saving indicator
            const saveBtn = document.querySelector(`#annotation-${imageIndex} .btn-warning`);
            const originalText = saveBtn ? saveBtn.innerHTML : '';
            if (saveBtn) {
                saveBtn.innerHTML = '‚è≥ Saving...';
                saveBtn.disabled = true;
            }
            
            const annotationData = {
                session_id: currentTrainingSession.id,
                image_index: imageIndex,
                image_filename: currentTrainingSession.images[imageIndex].filename,
                annotations: annotations[imageIndex],
                annotated_image: imageData
            };
            
            console.log(`üíæ Saving annotations for image ${imageIndex + 1}...`);
            
            fetch('/api/tophat/save_annotations', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(annotationData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`‚úÖ Annotations saved for image ${imageIndex + 1}`);
                    alert('Annotations saved successfully!');
                    if (saveBtn) {
                        saveBtn.innerHTML = '‚úÖ Annotations Saved';
                        saveBtn.className = 'btn btn-success';
                        saveBtn.disabled = true;
                    }
                } else {
                    console.error(`‚ùå Failed to save annotations for image ${imageIndex + 1}:`, data.error);
                    alert('Failed to save annotations: ' + data.error);
                    // Restore button
                    if (saveBtn) {
                        saveBtn.innerHTML = originalText;
                        saveBtn.disabled = false;
                    }
                }
            })
            .catch(error => {
                console.error('Annotation save error:', error);
                alert('Failed to save annotations: Network error');
                // Restore button
                if (saveBtn) {
                    saveBtn.innerHTML = originalText;
                    saveBtn.disabled = false;
                }
            });
        }

        function loadImageToCanvas(imageIndex, imageData) {
            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            const ctx = canvas.getContext('2d');
            const loadingIndicator = document.getElementById(`canvas-loading-${imageIndex}`);
            
            // Initialize drawing state first
            drawingState[imageIndex] = {
                isDrawing: false,
                mode: 'correct',
                lastX: 0,
                lastY: 0,
                currentPath: []
            };

            
            annotations[imageIndex] = {
                correct: [],
                false_positive: [],
                missed: []
            };
            
            // Set default drawing mode to correct
            setTimeout(() => setDrawingMode(imageIndex, 'correct'), 100);
            
            // Create an image element to load the detection result
            const img = new Image();
            img.onload = function() {
                // Hide loading indicator
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
                
                // Set canvas size to match image (with max constraints)
                const maxWidth = 800;
                const maxHeight = 600;
                
                let canvasWidth = img.width;
                let canvasHeight = img.height;
                
                // Scale down if too large
                if (canvasWidth > maxWidth) {
                    const scale = maxWidth / canvasWidth;
                    canvasWidth = maxWidth;
                    canvasHeight = canvasHeight * scale;
                }
                
                if (canvasHeight > maxHeight) {
                    const scale = maxHeight / canvasHeight;
                    canvasHeight = maxHeight;
                    canvasWidth = canvasWidth * scale;
                }
                
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                
                // Draw the detection result image
                ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                
                console.log(`‚úÖ Loaded training image ${imageIndex + 1} onto canvas (${canvasWidth}x${canvasHeight})`);
            };
            
            img.onerror = function() {
                console.error(`‚ùå Failed to load training image ${imageIndex + 1}`);
                
                // Hide loading indicator and show error
                if (loadingIndicator) {
                    loadingIndicator.innerHTML = `
                        <div style="color: #dc3545; font-size: 16px;">‚ùå Image loading failed</div>
                        <div style="font-size: 14px; color: #666; margin-top: 10px;">You can still draw annotations</div>
                    `;
                    setTimeout(() => {
                        if (loadingIndicator) loadingIndicator.style.display = 'none';
                    }, 3000);
                }
                
                // Fallback to placeholder
                canvas.width = 600;
                canvas.height = 400;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#333';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Original image unavailable', canvas.width/2, canvas.height/2 - 10);
                ctx.fillText('Draw annotations here', canvas.width/2, canvas.height/2 + 10);
            };
            
            // FIXED: For tophat training, load the original uploaded image for annotation
            console.log(`üì∏ Loading original image for tophat training ${imageIndex + 1}...`);
            console.log('Available imageData:', imageData);
            
            // Handle tophat training data structure - FIXED
            let filename = null;
            
            // First try the upload_filename (for tophat training)
            if (imageData.upload_filename) {
                filename = imageData.upload_filename;
                console.log(`üéØ Using upload_filename: ${filename}`);
            } else if (imageData.path) {
                // Fallback to extracting from path
                if (imageData.path.includes('uploads/')) {
                    filename = imageData.path.split('/').pop();
                } else {
                    // If path doesn't include uploads/, it might be a full path - extract filename
                    filename = imageData.path.split(/[/\\]/).pop();
                }
                console.log(`üîÑ Extracted filename from path: ${filename}`);
            }
            
            // Prioritize detection visualization for annotation (shows detected cells)
            if (imageData.image_data && imageData.image_data.visualizations && imageData.image_data.visualizations.detection_overview) {
                console.log(`üéØ Using detection visualization for tophat training ${imageIndex + 1}...`);
                img.src = `data:image/png;base64,${imageData.image_data.visualizations.detection_overview}`;
            } else if (filename) {
                // Fallback to browser-compatible image via display route
                console.log(`üîÑ Fallback to browser-compatible image: /uploads/display/${filename}`);
                img.src = `/uploads/display/${filename}`;
            } else {
                // Last resort: show placeholder and log error
                console.warn(`‚ö†Ô∏è No image source available for image ${imageIndex + 1}`);
                console.warn('imageData structure:', imageData);
                console.warn('Expected: imageData.image_data.visualizations.detection_overview or filename');
                img.onerror();
            }
        }

        // Touch support for mobile devices
        function handleTouch(event, imageIndex, phase) {
            event.preventDefault(); // Prevent scrolling
            
            if (!event.touches || event.touches.length === 0) return;
            
            const touch = event.touches[0];
            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            const rect = canvas.getBoundingClientRect();
            
            // Create a synthetic mouse event
            const mouseEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY,
                target: canvas
            };
            
            switch (phase) {
                case 'start':
                    startDrawing(mouseEvent, imageIndex);
                    break;
                case 'move':
                    draw(mouseEvent, imageIndex);
                    break;
                case 'end':
                    stopDrawing(imageIndex);
                    break;
            }
        }

        function setDrawingMode(imageIndex, mode) {
            if (!drawingState[imageIndex]) return;
            
            drawingState[imageIndex].mode = mode;
            
            // Update button styles with better visual feedback
            const buttons = {
                'correct': document.getElementById(`correct-btn-${imageIndex}`),
                'false_positive': document.getElementById(`false-btn-${imageIndex}`),
                'missed': document.getElementById(`missed-btn-${imageIndex}`)
            };
            
            // Reset all button styles
            Object.values(buttons).forEach(btn => {
                if (btn) {
                    btn.style.transform = 'scale(1)';
                    btn.style.boxShadow = 'none';
                    btn.style.border = '2px solid transparent';
                }
            });
            
            // Highlight selected button
            if (buttons[mode]) {
                buttons[mode].style.transform = 'scale(1.1)';
                buttons[mode].style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
                buttons[mode].style.border = '2px solid #fff';
            }
            
            // Update canvas cursor and border color based on mode
            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            const colors = {
                'correct': '#28a745',
                'false_positive': '#dc3545',
                'missed': '#007bff'
            };
            
            if (canvas) {
                canvas.style.borderColor = colors[mode];
                canvas.style.borderWidth = '3px';
                
                // Update cursor style
                canvas.style.cursor = 'crosshair';
            }
            
            console.log(`üé® Drawing mode set to: ${mode} for image ${imageIndex + 1}`);
        }

        function startDrawing(event, imageIndex) {
            if (!drawingState[imageIndex]) return;
            drawingState[imageIndex].isDrawing = true;
            const rect = event.target.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Start a new path
            if (!drawingState[imageIndex].currentPath) {
                drawingState[imageIndex].currentPath = [];
            }
            drawingState[imageIndex].currentPath.push([x, y]);

            drawingState[imageIndex].lastX = x;
            drawingState[imageIndex].lastY = y;
        }

        function draw(event, imageIndex) {
            if (!drawingState[imageIndex] || !drawingState[imageIndex].isDrawing) return;

            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;

            const mode = drawingState[imageIndex].mode;
            const colorMap = {
                'correct': '#28a745',
                'false_positive': '#dc3545',
                'missed': '#007bff'
            };

            ctx.strokeStyle = colorMap[mode];
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(drawingState[imageIndex].lastX, drawingState[imageIndex].lastY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();

            drawingState[imageIndex].lastX = currentX;
            drawingState[imageIndex].lastY = currentY;

            // Add to current path
            drawingState[imageIndex].currentPath.push([currentX, currentY]);
        }

        function stopDrawing(imageIndex) {
            if (!drawingState[imageIndex] || !drawingState[imageIndex].isDrawing) return;
            drawingState[imageIndex].isDrawing = false;

            const mode = drawingState[imageIndex].mode;
            const path = drawingState[imageIndex].currentPath;

            if (path && path.length > 2) {
                // Save polygon to annotations
                annotations[imageIndex][mode].push(path);
            }

            drawingState[imageIndex].currentPath = [];
        }


        function clearDrawing(imageIndex) {
            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            if (canvas) {
                // Clear annotations
                annotations[imageIndex] = { correct: [], false_positive: [], missed: [] };
                
                // Reload the original image
                const image = currentTrainingSession.images[imageIndex];
                loadImageToCanvas(imageIndex, image);
            }
        }

        function updateOverallProgress(completed, total) {
            const progressFill = document.getElementById('overall-progress-fill');
            const currentProgress = document.getElementById('current-progress');
            
            if (progressFill) {
                const percentage = (completed / total) * 100;
                progressFill.style.width = `${percentage}%`;
            }
            
            if (currentProgress) {
                currentProgress.textContent = completed;
            }
        }

        function refreshModelStatus() {
            const refreshBtn = document.getElementById('refreshModelsBtn');
            const originalText = refreshBtn.innerHTML;
            
            // Show loading state
            refreshBtn.innerHTML = '‚è≥ Refreshing...';
            refreshBtn.disabled = true;
            
            fetch('/api/refresh_models', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update model status indicators
                    const wolffiaCNNStatus = document.getElementById('wolffiaCNNStatus');
                    const checkbox = document.getElementById('useWolffiaCNN');
                    
                    if (data.ai_status && data.ai_status.wolffia_cnn_available) {
                        wolffiaCNNStatus.innerHTML = 'Wolffia CNN model is ready for enhanced detection';
                        wolffiaCNNStatus.className = 'status-indicator status-success';
                        checkbox.disabled = false;
                        checkbox.checked = true;
                    } else {
                        wolffiaCNNStatus.innerHTML = 'Wolffia CNN model not trained yet. Run: python train_wolffia_cnn.py';
                        wolffiaCNNStatus.className = 'status-indicator status-warning';
                        checkbox.disabled = true;
                        checkbox.checked = false;
                    }
                    
                    // Success feedback
                    refreshBtn.innerHTML = '‚úÖ Refreshed!';
                    refreshBtn.style.background = '#28a745';
                    
                    setTimeout(() => {
                        refreshBtn.innerHTML = originalText;
                        refreshBtn.style.background = '#28a745';
                        refreshBtn.disabled = false;
                    }, 2000);
                    
                } else {
                    throw new Error(data.error || 'Refresh failed');
                }
            })
            .catch(error => {
                console.error('Model refresh error:', error);
                
                // Error feedback
                refreshBtn.innerHTML = '‚ùå Failed';
                refreshBtn.style.background = '#dc3545';
                
                setTimeout(() => {
                    refreshBtn.innerHTML = originalText;
                    refreshBtn.style.background = '#28a745';
                    refreshBtn.disabled = false;
                }, 2000);
            });
        }

        function exportResults(analysisId, format) {
            window.open(`/api/export/${analysisId}/${format}`, '_blank');
        }
        
        function switchMethodTab(analysisId, methodKey, clickedTab) {
            // Hide all panels for this analysis
            const allPanels = document.querySelectorAll(`[id^="${analysisId}-panel-"]`);
            allPanels.forEach(panel => panel.classList.remove('active'));
            
            // Remove active class from all tabs in this container
            const tabContainer = clickedTab.parentElement;
            const allTabs = tabContainer.querySelectorAll('.method-tab');
            allTabs.forEach(tab => tab.classList.remove('active'));
            
            // Show selected panel and activate tab
            const targetPanel = document.getElementById(`${analysisId}-panel-${methodKey}`);
            if (targetPanel) {
                targetPanel.classList.add('active');
            }
            clickedTab.classList.add('active');
        }
        
        function exportMethodResults(analysisId, methodKey, format) {
            // For now, export the general results - could be enhanced to export specific method data
            window.open(`/api/export/${analysisId}/${format}`, '_blank');
        }
    </script>
</body>
</html>