<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIOIMAGIN Focused - Professional Wolffia Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 40px;
            padding: 25px;
            border-radius: 10px;
            background: #f8f9fa;
            border-left: 5px solid #007bff;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .upload-area {
            border: 3px dashed #007bff;
            border-radius: 10px;
            padding: 50px;
            text-align: center;
            background: white;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #0056b3;
            background: #f8f9fa;
        }

        .upload-area.dragover {
            border-color: #28a745;
            background: #d4edda;
        }

        .file-input {
            display: none;
        }

        .upload-text {
            font-size: 1.2em;
            color: #6c757d;
            margin-bottom: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
        }

        .btn-primary {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
        }

        .options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .option-group {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .option-group h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            background: #f8f9fa;
            transition: all 0.3s ease;
        }

        .checkbox-container:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .checkbox-container input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #007bff;
        }

        .status-indicator {
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .files-list {
            margin-top: 20px;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            color: #2c3e50;
        }

        .file-status {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #28a745);
            width: 0%;
            transition: width 0.3s ease;
        }

        .results-container {
            margin-top: 30px;
        }

        .result-item {
            background: white;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .result-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
        }

        .detection-method {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            color: white;
        }

        .method-ai {
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .method-classical {
            background: linear-gradient(135deg, #ffc107, #e0a800);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .metric-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .metric-label {
            color: #6c757d;
            font-size: 0.9em;
        }

        .biomass-card {
            background: linear-gradient(135deg, #28a745, #20c997) !important;
            color: white;
        }

        .biomass-card .metric-value {
            color: white;
        }

        .biomass-card .metric-label {
            color: rgba(255,255,255,0.9);
        }

        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .visualization-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .visualization-item h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .visualization-item img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .export-section {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .temporal-section {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            border-left-color: #ff9800;
        }

        .batch-progress {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .health-indicator {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            color: white;
            margin: 0 5px;
        }

        .health-excellent { background: #28a745; }
        .health-good { background: #6f42c1; }
        .health-moderate { background: #ffc107; color: #000; }
        .health-poor { background: #dc3545; }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .main-content {
                padding: 20px;
            }

            .options {
                grid-template-columns: 1fr;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }

            .visualization-grid {
                grid-template-columns: 1fr;
            }

            .export-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ BIOIMAGIN Focused</h1>
            <p>Professional Wolffia Arrhiza Analysis & Quantification System</p>
        </div>

        <div class="main-content">
            <!-- Image Upload Section -->
            <div class="section">
                <h2>üì∏ Image Upload & Analysis Configuration</h2>
                
                <div class="upload-area" id="uploadArea">
                    <div class="upload-text">
                        <strong>Drop images here or click to select</strong><br>
                        Supports: PNG, JPG, JPEG, BMP, TIFF (Max 100MB each)
                    </div>
                    <input type="file" id="fileInput" class="file-input" multiple accept=".png,.jpg,.jpeg,.bmp,.tiff,.tif,.jfif">
                    <button class="btn" onclick="document.getElementById('fileInput').click()">
                        üìÅ Select Images
                    </button>
                </div>

                <div class="options">
                    <!-- AI Detection Options -->
                    <div class="option-group">
                        <h3>üß† AI Detection</h3>
                        <div class="checkbox-container">
                            <input type="checkbox" id="useCellDetection" checked>
                            <label for="useCellDetection"><strong>Use CellDetection AI</strong> (Recommended)</label>
                        </div>
                        <div id="celldetectionStatus" class="status-indicator" style="display: none;">
                            Checking AI model status...
                        </div>
                        
                        <div class="checkbox-container">
                            <input type="checkbox" id="useTophat">
                            <label for="useTophat"><strong>Use Tophat AI Model</strong> (if trained)</label>
                        </div>
                        <div id="tophatStatus" class="status-indicator" style="display: none;">
                            Checking Tophat model status...
                        </div>
                    </div>
                    
                    <!-- Temporal Analysis Options -->
                    <div class="option-group">
                        <h3>‚è±Ô∏è Temporal Analysis</h3>
                        <div class="checkbox-container">
                            <input type="checkbox" id="enableTemporal">
                            <label for="enableTemporal"><strong>Enable Time-Series Analysis</strong></label>
                        </div>
                        <p style="font-size: 0.9em; color: #6c757d; margin-top: 10px;">
                            Track changes over time when uploading multiple images from different time points
                        </p>
                    </div>
                    
                    <!-- Analysis Controls -->
                    <div class="option-group">
                        <h3>üéØ Analysis Control</h3>
                        <button class="btn btn-success" id="analyzeBtn" onclick="startAnalysis()" disabled>
                            üß¨ Start Individual Analysis
                        </button>
                        <button class="btn btn-primary" id="batchAnalyzeBtn" onclick="startBatchAnalysis()" disabled>
                            üìä Start Batch Analysis
                        </button>
                    </div>
                </div>

                <div class="files-list" id="filesList"></div>
            </div>

            <!-- Batch Progress Section -->
            <div id="batchProgressSection" style="display: none;">
                <div class="batch-progress">
                    <h3>üìä Batch Analysis Progress</h3>
                    <div class="progress-bar" style="margin: 20px auto; max-width: 500px;">
                        <div class="progress-fill" id="batchProgressFill"></div>
                    </div>
                    <p id="batchProgressText">Preparing analysis...</p>
                </div>
            </div>

            <!-- Results Section -->
            <div class="section" id="resultsSection" style="display: none;">
                <h2>üìä Analysis Results</h2>
                <div class="results-container" id="resultsContainer"></div>
            </div>

            <!-- Tophat Training Section -->
            <div class="section" style="background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); border-left-color: #ffc107;">
                <h2>üéØ Tophat AI Training</h2>
                <p>Train the AI to better detect cells by correcting automatic detections</p>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">
                    <div style="background: white; padding: 20px; border-radius: 10px; text-align: center;">
                        <div style="background: #ffc107; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 20px; font-weight: bold;">1</div>
                        <h4>Upload Images</h4>
                        <p>Upload multiple images for training</p>
                    </div>
                    <div style="background: white; padding: 20px; border-radius: 10px; text-align: center;">
                        <div style="background: #ffc107; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 20px; font-weight: bold;">2</div>
                        <h4>Review Detections</h4>
                        <p>Mark correct and incorrect cell detections</p>
                    </div>
                    <div style="background: white; padding: 20px; border-radius: 10px; text-align: center;">
                        <div style="background: #ffc107; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 20px; font-weight: bold;">3</div>
                        <h4>Train Model</h4>
                        <p>AI learns from your corrections</p>
                    </div>
                </div>

                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-warning" id="startTrainingBtn" onclick="startTophatTraining()" disabled>
                        üß† Start Training Session
                    </button>
                </div>

                <div id="trainingContainer" style="display: none; margin-top: 20px;">
                    <!-- Training interface will be loaded here -->
                </div>
            </div>

            <!-- System Status Section -->
            <div class="section" style="background: linear-gradient(135deg, #f0f8ff, #e6f3ff);">
                <h2>üîß System Status</h2>
                <div id="systemStatus">
                    <p>Loading system status...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let uploadedFiles = [];
        let analysisResults = {};
        let batchAnalysisId = null;

        // Initialize system
        window.addEventListener('load', () => {
            checkSystemStatus();
        });

        function checkSystemStatus() {
            // Check CellDetection status
            fetch('/api/celldetection/status')
                .then(response => response.json())
                .then(data => {
                    const statusDiv = document.getElementById('celldetectionStatus');
                    const checkbox = document.getElementById('useCellDetection');
                    
                    if (data.success && data.status.available && data.status.model_loaded) {
                        statusDiv.innerHTML = `‚úÖ CellDetection AI ready (${data.status.device.toUpperCase()})`;
                        statusDiv.className = 'status-indicator status-success';
                        checkbox.disabled = false;
                    } else if (data.success && data.status.available && !data.status.model_loaded) {
                        statusDiv.innerHTML = '‚ö†Ô∏è CellDetection available but model not loaded';
                        statusDiv.className = 'status-indicator status-warning';
                        checkbox.disabled = false;
                    } else {
                        statusDiv.innerHTML = '‚ùå CellDetection not available';
                        statusDiv.className = 'status-indicator status-error';
                        checkbox.disabled = true;
                        checkbox.checked = false;
                    }
                    statusDiv.style.display = 'block';
                })
                .catch(error => {
                    console.error('Error checking CellDetection status:', error);
                });

            // Check Tophat status
            fetch('/api/tophat/model_status')
                .then(response => response.json())
                .then(data => {
                    const statusDiv = document.getElementById('tophatStatus');
                    const checkbox = document.getElementById('useTophat');
                    
                    if (data.model_available) {
                        statusDiv.innerHTML = '‚úÖ Tophat AI model is available';
                        statusDiv.className = 'status-indicator status-success';
                        checkbox.disabled = false;
                    } else {
                        statusDiv.innerHTML = '‚ö†Ô∏è No Tophat model trained yet. Use training section below.';
                        statusDiv.className = 'status-indicator status-warning';
                        checkbox.disabled = true;
                        checkbox.checked = false;
                    }
                    statusDiv.style.display = 'block';
                })
                .catch(error => {
                    console.error('Error checking Tophat status:', error);
                });

            // Update system status display
            fetch('/api/health')
                .then(response => response.json())
                .then(data => {
                    const statusDiv = document.getElementById('systemStatus');
                    statusDiv.innerHTML = `
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div>
                                <strong>System Status:</strong><br>
                                <span style="color: #28a745;">‚óè</span> ${data.status.toUpperCase()}
                            </div>
                            <div>
                                <strong>Version:</strong><br>
                                ${data.version}
                            </div>
                            <div>
                                <strong>Features:</strong><br>
                                ${data.features.length} modules active
                            </div>
                        </div>
                    `;
                })
                .catch(error => {
                    console.error('Error checking system health:', error);
                });
        }

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files);
            handleFiles(files);
        });

        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            handleFiles(files);
        });

        function handleFiles(files) {
            const validFiles = files.filter(file => {
                const validTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/bmp', 'image/tiff'];
                return validTypes.includes(file.type) && file.size <= 100 * 1024 * 1024;
            });

            if (validFiles.length === 0) {
                alert('No valid image files selected. Please select PNG, JPG, BMP, or TIFF files under 100MB.');
                return;
            }

            // Upload files
            const formData = new FormData();
            validFiles.forEach(file => formData.append('files', file));
            formData.append('use_celldetection', document.getElementById('useCellDetection').checked);
            formData.append('enable_temporal', document.getElementById('enableTemporal').checked);

            fetch('/api/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    uploadedFiles = data.files;
                    displayFiles();
                    document.getElementById('analyzeBtn').disabled = false;
                    document.getElementById('batchAnalyzeBtn').disabled = false;
                    document.getElementById('startTrainingBtn').disabled = false;
                    
                    if (data.temporal_analysis_enabled) {
                        alert(`‚úÖ ${data.files.length} files uploaded with temporal analysis enabled!`);
                    }
                } else {
                    alert('Upload failed: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Upload error:', error);
                alert('Upload failed. Please try again.');
            });
        }

        function displayFiles() {
            const filesList = document.getElementById('filesList');
            filesList.innerHTML = '';

            if (uploadedFiles.length === 0) return;

            const filesHeader = document.createElement('h3');
            filesHeader.textContent = `üìÅ Uploaded Files (${uploadedFiles.length})`;
            filesHeader.style.color = '#2c3e50';
            filesHeader.style.marginBottom = '15px';
            filesList.appendChild(filesHeader);

            uploadedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div class="file-info">
                        <div class="file-name">
                            ${index + 1}. ${file.filename}
                            ${file.timestamp ? `<span style="color: #007bff; font-size: 0.8em;">[${file.timestamp}]</span>` : ''}
                        </div>
                        <div class="file-status" id="status-${file.id}">Ready for analysis</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-${file.id}"></div>
                        </div>
                    </div>
                `;
                filesList.appendChild(fileItem);
            });
        }

        function startAnalysis() {
            if (uploadedFiles.length === 0) {
                alert('Please upload images first');
                return;
            }

            document.getElementById('resultsSection').style.display = 'block';
            const resultsContainer = document.getElementById('resultsContainer');
            resultsContainer.innerHTML = '';

            // Add progress indicator
            const progressIndicator = document.createElement('div');
            progressIndicator.className = 'batch-progress';
            progressIndicator.id = 'overall-progress';
            progressIndicator.innerHTML = `
                <h4>üìä Analyzing ${uploadedFiles.length} images individually...</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="overall-progress-fill"></div>
                </div>
                <p>Processing: <span id="current-progress">0</span> / ${uploadedFiles.length} completed</p>
            `;
            resultsContainer.appendChild(progressIndicator);

            let completedAnalyses = 0;
            
            // Analyze each file individually
            uploadedFiles.forEach((file, index) => {
                setTimeout(() => {
                    analyzeFile(file, () => {
                        completedAnalyses++;
                        updateOverallProgress(completedAnalyses, uploadedFiles.length);
                        
                        if (completedAnalyses === uploadedFiles.length) {
                            setTimeout(() => {
                                const progressDiv = document.getElementById('overall-progress');
                                if (progressDiv) {
                                    progressDiv.innerHTML = `
                                        <h4>‚úÖ All individual analyses completed!</h4>
                                        <p>Successfully processed ${uploadedFiles.length} images.</p>
                                    `;
                                    progressDiv.className = 'batch-progress';
                                    progressDiv.style.background = '#d4edda';
                                }
                            }, 1000);
                        }
                    });
                }, index * 200);
            });
        }

        function startBatchAnalysis() {
            if (uploadedFiles.length === 0) {
                alert('Please upload images first');
                return;
            }

            const enableTemporal = document.getElementById('enableTemporal').checked;
            const useCellDetection = document.getElementById('useCellDetection').checked;

            // Show batch progress section
            document.getElementById('batchProgressSection').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'block';

            // Start batch analysis
            fetch('/api/analyze_batch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    files: uploadedFiles,
                    use_celldetection: useCellDetection,
                    enable_temporal: enableTemporal
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    batchAnalysisId = data.batch_id;
                    pollBatchAnalysisStatus(data.batch_id);
                } else {
                    alert('Batch analysis failed: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Batch analysis error:', error);
                alert('Batch analysis failed');
            });
        }

        function pollBatchAnalysisStatus(batchId) {
            const poll = () => {
                fetch(`/api/status/${batchId}`)
                    .then(response => response.json())
                    .then(data => {
                        const progressFill = document.getElementById('batchProgressFill');
                        const progressText = document.getElementById('batchProgressText');
                        
                        if (progressFill) {
                            progressFill.style.width = data.progress + '%';
                        }
                        
                        if (data.status === 'completed') {
                            if (progressText) {
                                progressText.textContent = '‚úÖ Batch analysis completed!';
                            }
                            displayBatchResults(data.result);
                        } else if (data.status === 'error') {
                            if (progressText) {
                                progressText.textContent = '‚ùå Batch analysis failed: ' + data.error;
                            }
                        } else {
                            if (progressText) {
                                progressText.textContent = 'Processing batch analysis...';
                            }
                            setTimeout(poll, 2000);
                        }
                    })
                    .catch(error => {
                        console.error('Status check error:', error);
                    });
            };

            poll();
        }

        function analyzeFile(file, onComplete) {
            const statusElement = document.getElementById(`status-${file.id}`);
            const progressElement = document.getElementById(`progress-${file.id}`);
            
            statusElement.textContent = 'Starting analysis...';
            progressElement.style.width = '10%';

            const useCellDetection = document.getElementById('useCellDetection').checked;
            const useTophat = document.getElementById('useTophat').checked;

            fetch(`/api/analyze/${file.id}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    files: [file],
                    use_celldetection: useCellDetection,
                    use_tophat: useTophat
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    pollAnalysisStatus(file.id, file.filename, onComplete);
                } else {
                    statusElement.textContent = 'Analysis failed: ' + data.error;
                    statusElement.style.color = 'red';
                    if (onComplete) onComplete();
                }
            })
            .catch(error => {
                console.error('Analysis error:', error);
                statusElement.textContent = 'Analysis failed';
                statusElement.style.color = 'red';
                if (onComplete) onComplete();
            });
        }

        function pollAnalysisStatus(analysisId, filename, onComplete) {
            const statusElement = document.getElementById(`status-${analysisId}`);
            const progressElement = document.getElementById(`progress-${analysisId}`);

            const poll = () => {
                fetch(`/api/status/${analysisId}`)
                    .then(response => response.json())
                    .then(data => {
                        progressElement.style.width = data.progress + '%';
                        
                        if (data.status === 'completed') {
                            statusElement.textContent = 'Analysis completed ‚úÖ';
                            statusElement.style.color = 'green';
                            progressElement.style.width = '100%';
                            displayResults(analysisId, filename, data.result);
                            if (onComplete) onComplete();
                        } else if (data.status === 'error') {
                            statusElement.textContent = 'Analysis failed: ' + data.error;
                            statusElement.style.color = 'red';
                            if (onComplete) onComplete();
                        } else {
                            statusElement.textContent = 'Processing...';
                            setTimeout(poll, 1000);
                        }
                    })
                    .catch(error => {
                        console.error('Status check error:', error);
                        statusElement.textContent = 'Status check failed';
                        statusElement.style.color = 'red';
                        if (onComplete) onComplete();
                    });
            };

            poll();
        }

        function displayResults(analysisId, filename, result) {
            const resultsContainer = document.getElementById('resultsContainer');
            
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';
            
            // Extract data
            const detection = result.detection_results || {};
            const quantitative = result.quantitative_analysis || {};
            const biomass = quantitative.biomass_analysis || {};
            const color = quantitative.color_analysis || {};
            const health = quantitative.health_assessment || {};
            const temporal = result.temporal_analysis;
            const visualizations = result.visualizations || {};
            const legend = visualizations.detection_legend || {};
            
            resultItem.innerHTML = `
                <div class="result-header">
                    <div class="result-title">üìÑ ${filename}</div>
                    <div class="detection-method ${detection.detection_method && detection.detection_method.includes('AI') ? 'method-ai' : 'method-classical'}">
                        ${detection.detection_method || 'Unknown Method'}
                    </div>
                </div>

                <!-- Detection Legend (moved outside image) -->
                ${legend.total_cells ? `
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0; border-left: 4px solid #007bff;">
                    <h4 style="color: #2c3e50; margin-bottom: 15px;">üîç Detection Summary & Color Legend</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                        <div>
                            <strong>Detection Results:</strong><br>
                            ‚Ä¢ Total Cells: ${legend.total_cells}<br>
                            ‚Ä¢ Total Biomass: ${legend.metrics?.total_biomass_mg?.toFixed(3) || '0.000'} mg<br>
                            ‚Ä¢ Avg Cell Area: ${legend.metrics?.average_cell_area?.toFixed(1) || '0.0'} pixels¬≤<br>
                            ‚Ä¢ Green Cells: ${legend.metrics?.green_cell_percentage?.toFixed(1) || '0.0'}%<br>
                            ‚Ä¢ Health Status: ${legend.metrics?.health_status?.charAt(0).toUpperCase() + legend.metrics?.health_status?.slice(1) || 'Unknown'}
                        </div>
                        <div>
                            <strong>Color Legend:</strong><br>
                            <div style="display: flex; align-items: center; margin: 5px 0;">
                                <div style="width: 20px; height: 20px; background: lime; border-radius: 50%; margin-right: 10px;"></div>
                                <span>High Biomass (${legend.color_coding?.high_biomass?.threshold || '>0.1 mg'}): ${legend.color_coding?.high_biomass?.count || 0} cells</span>
                            </div>
                            <div style="display: flex; align-items: center; margin: 5px 0;">
                                <div style="width: 20px; height: 20px; background: yellow; border-radius: 50%; margin-right: 10px;"></div>
                                <span>Medium Biomass (${legend.color_coding?.medium_biomass?.threshold || '0.05-0.1 mg'}): ${legend.color_coding?.medium_biomass?.count || 0} cells</span>
                            </div>
                            <div style="display: flex; align-items: center; margin: 5px 0;">
                                <div style="width: 20px; height: 20px; background: red; border-radius: 50%; margin-right: 10px;"></div>
                                <span>Low Biomass (${legend.color_coding?.low_biomass?.threshold || '<0.05 mg'}): ${legend.color_coding?.low_biomass?.count || 0} cells</span>
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- Key Metrics -->
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">${detection.cells_detected || 0}</div>
                        <div class="metric-label">Cells Detected</div>
                    </div>
                    <div class="metric-card biomass-card">
                        <div class="metric-value">${biomass.total_biomass_mg?.toFixed(3) || '0.000'}</div>
                        <div class="metric-label">Total Biomass (mg)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${color.green_cell_percentage?.toFixed(1) || '0.0'}%</div>
                        <div class="metric-label">Green Cells</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${quantitative.average_cell_area?.toFixed(1) || '0.0'}</div>
                        <div class="metric-label">Avg Area (pixels¬≤)</div>
                    </div>
                </div>

                <!-- Health Status -->
                ${health.overall_health ? `
                <div style="text-align: center; margin: 20px 0;">
                    <span class="health-indicator health-${health.overall_health}">
                        Population Health: ${health.overall_health.toUpperCase()}
                    </span>
                    <span style="margin-left: 15px; color: #6c757d;">
                        Score: ${health.health_score?.toFixed(2) || '0.00'}/1.0
                    </span>
                </div>
                ` : ''}

                <!-- Visualizations -->
                <div class="visualization-grid" id="viz-${analysisId}">
                    <!-- Visualizations will be loaded here -->
                </div>

                <!-- Temporal Analysis -->
                ${temporal && temporal.time_points > 1 ? `
                <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin: 20px 0;">
                    <h4>‚è±Ô∏è Temporal Analysis</h4>
                    <p><strong>Time Points:</strong> ${temporal.time_points}</p>
                    <p><strong>Trend:</strong> ${temporal.temporal_trend?.replace('_', ' ').toUpperCase() || 'Unknown'}</p>
                    ${temporal.growth_analysis ? `
                    <p><strong>Cell Count Change:</strong> ${temporal.growth_analysis.avg_cell_count_change_percent?.toFixed(1) || '0.0'}% average</p>
                    ` : ''}
                </div>
                ` : ''}

                <!-- Export Section -->
                <div class="export-section">
                    <h4 style="text-align: center; margin-bottom: 15px;">üì• Export Results</h4>
                    <div class="export-buttons">
                        <button class="btn" onclick="exportResults('${analysisId}', 'csv')">üìä Export CSV</button>
                        <button class="btn" onclick="exportResults('${analysisId}', 'excel')">üìà Export Excel</button>
                        <button class="btn" onclick="exportResults('${analysisId}', 'json')">üìÑ Export JSON</button>
                        <button class="btn btn-success" onclick="exportResults('${analysisId}', 'report')">üìã Full Report (ZIP)</button>
                    </div>
                </div>
            `;
            
            resultsContainer.appendChild(resultItem);
            
            // Load visualizations (excluding health dashboard)
            loadVisualizations(analysisId, result.visualizations);
            
            resultItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function displayBatchResults(batchResult) {
            const resultsContainer = document.getElementById('resultsContainer');
            
            const batch = batchResult.batch_summary || {};
            const aggregate = batch.aggregate_statistics || {};
            
            const batchItem = document.createElement('div');
            batchItem.className = 'result-item';
            batchItem.style.background = 'linear-gradient(135deg, #e3f2fd, #bbdefb)';
            
            batchItem.innerHTML = `
                <div class="result-header">
                    <div class="result-title">üìä Batch Analysis Results</div>
                    <div style="color: #1976d2; font-weight: bold;">
                        ${batch.successful_analyses || 0}/${batch.total_files || 0} Files Processed
                    </div>
                </div>

                <!-- Aggregate Metrics -->
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">${aggregate.total_cells_detected || 0}</div>
                        <div class="metric-label">Total Cells Detected</div>
                    </div>
                    <div class="metric-card biomass-card">
                        <div class="metric-value">${aggregate.total_biomass_mg?.toFixed(3) || '0.000'}</div>
                        <div class="metric-label">Total Biomass (mg)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${aggregate.average_green_cell_percentage?.toFixed(1) || '0.0'}%</div>
                        <div class="metric-label">Avg Green Cells</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${batchResult.temporal_analysis ? 'Yes' : 'No'}</div>
                        <div class="metric-label">Temporal Analysis</div>
                    </div>
                </div>

                <!-- Health Distribution -->
                ${aggregate.health_distribution_aggregate ? `
                <div style="background: white; padding: 15px; border-radius: 8px; margin: 20px 0;">
                    <h4>üè• Population Health Distribution (Aggregate)</h4>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                        <span class="health-indicator health-excellent">Excellent: ${aggregate.health_distribution_aggregate.excellent || 0}</span>
                        <span class="health-indicator health-good">Good: ${aggregate.health_distribution_aggregate.good || 0}</span>
                        <span class="health-indicator health-moderate">Moderate: ${aggregate.health_distribution_aggregate.moderate || 0}</span>
                        <span class="health-indicator health-poor">Poor: ${aggregate.health_distribution_aggregate.poor || 0}</span>
                    </div>
                </div>
                ` : ''}

                <!-- Export Section -->
                <div class="export-section">
                    <h4 style="text-align: center; margin-bottom: 15px;">üì• Export Batch Results</h4>
                    <div class="export-buttons">
                        <button class="btn" onclick="exportResults('${batchAnalysisId}', 'csv')">üìä Export Batch CSV</button>
                        <button class="btn" onclick="exportResults('${batchAnalysisId}', 'excel')">üìà Export Batch Excel</button>
                        <button class="btn btn-success" onclick="exportResults('${batchAnalysisId}', 'report')">üìã Complete Batch Report</button>
                    </div>
                </div>
            `;
            
            resultsContainer.appendChild(batchItem);
            
            // Display individual results
            const individualResults = batchResult.individual_results || [];
            individualResults.forEach((result, index) => {
                if (result.success) {
                    const filename = uploadedFiles[index]?.filename || `Image_${index + 1}`;
                    displayResults(`batch_${index}`, filename, result);
                }
            });
        }

        function loadVisualizations(analysisId, visualizations) {
            if (!visualizations) return;
            
            const vizContainer = document.getElementById(`viz-${analysisId}`);
            if (!vizContainer) return;
            
            // Define visualization priorities and titles (excluding health_dashboard)
            const vizConfig = {
                'detection_overview': 'Cell Detection Overview',
                'size_histogram': 'Size Distribution',
                'biomass_chart': 'Biomass Analysis',
                'color_analysis': 'Color Analysis',
                'temporal_analysis': 'Temporal Changes'
            };
            
            Object.entries(vizConfig).forEach(([key, title]) => {
                if (visualizations[key]) {
                    const vizItem = document.createElement('div');
                    vizItem.className = 'visualization-item';
                    vizItem.innerHTML = `
                        <h4>${title}</h4>
                        <img src="data:image/png;base64,${visualizations[key]}" 
                             alt="${title}"
                             loading="lazy">
                    `;
                    vizContainer.appendChild(vizItem);
                }
            });
        }

        // Tophat Training Functions
        let currentTrainingSession = null;
        let drawingState = {};
        let annotations = {};

        function startTophatTraining() {
            if (uploadedFiles.length === 0) {
                alert('Please upload images first');
                return;
            }

            const trainingContainer = document.getElementById('trainingContainer');
            trainingContainer.style.display = 'block';
            trainingContainer.innerHTML = '<p>Starting training session...</p>';

            fetch('/api/tophat/start_training', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ files: uploadedFiles })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentTrainingSession = data.session;
                    displayTrainingInterface(data.session);
                } else {
                    trainingContainer.innerHTML = `<div class="status-indicator status-error">Training failed: ${data.error}</div>`;
                }
            })
            .catch(error => {
                console.error('Training start error:', error);
                trainingContainer.innerHTML = '<div class="status-indicator status-error">Failed to start training session</div>';
            });
        }

        function displayTrainingInterface(session) {
            const trainingContainer = document.getElementById('trainingContainer');
            
            let html = `
                <div class="status-indicator status-success">
                    Training session started with ${session.images_count} images
                </div>
                <p><strong>Instructions:</strong> For each image, you will draw directly on the image to mark correct cells (green) and false positives (red). This trains the AI to recognize cell patterns.</p>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0;">
                    <h4>üé® Drawing Instructions:</h4>
                    <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 20px; height: 20px; background: #28a745; border-radius: 50%;"></div>
                            <span><strong>Green:</strong> Draw around correct cells</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 20px; height: 20px; background: #dc3545; border-radius: 50%;"></div>
                            <span><strong>Red:</strong> Draw around false positives</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 20px; height: 20px; background: #007bff; border-radius: 50%;"></div>
                            <span><strong>Blue:</strong> Draw around missed cells</span>
                        </div>
                    </div>
                </div>
            `;

            session.images.forEach((image, index) => {
                html += `
                    <div class="result-item">
                        <h4>Image ${index + 1}: ${image.filename}</h4>
                        <p>Auto-detected cells: ${image.cells_count}</p>
                        <div style="text-align: center; margin: 20px 0;">
                            <button class="btn btn-warning" onclick="startDrawingAnnotation(${index})">
                                üé® Start Drawing Annotations
                            </button>
                        </div>
                        <div id="annotation-${index}" style="display: none;"></div>
                    </div>
                `;
            });

            html += `
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-success" onclick="finalizeTraining()">
                        üß† Finalize Training
                    </button>
                </div>
            `;

            trainingContainer.innerHTML = html;
        }

        function finalizeTraining() {
            if (!currentTrainingSession) {
                alert('No active training session');
                return;
            }

            fetch('/api/tophat/train_model', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: currentTrainingSession.id })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Tophat AI model trained successfully! You can now use it for analysis.');
                    checkSystemStatus(); // Refresh status
                } else {
                    alert('Training failed: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Training finalization error:', error);
                alert('Training finalization failed');
            });
        }

        function startDrawingAnnotation(imageIndex) {
            const annotationDiv = document.getElementById(`annotation-${imageIndex}`);
            annotationDiv.style.display = 'block';
            
            const image = currentTrainingSession.images[imageIndex];
            
            annotationDiv.innerHTML = `
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h4>üé® Drawing Tools</h4>
                        <p style="color: #666; font-size: 0.9em; margin: 10px 0;">
                            Select a tool below, then draw on the image to mark cells. 
                            Draw circles or outlines around cells you want to annotate.
                        </p>
                        <div style="display: flex; justify-content: center; gap: 15px; margin: 15px 0; flex-wrap: wrap;">
                            <button class="btn btn-success" onclick="setDrawingMode(${imageIndex}, 'correct')" id="correct-btn-${imageIndex}">
                                ‚úÖ Mark Correct Cells
                            </button>
                            <button class="btn" onclick="setDrawingMode(${imageIndex}, 'false_positive')" id="false-btn-${imageIndex}" style="background: #dc3545; color: white;">
                                ‚ùå Mark False Positives
                            </button>
                            <button class="btn btn-primary" onclick="setDrawingMode(${imageIndex}, 'missed')" id="missed-btn-${imageIndex}">
                                üîç Mark Missed Cells
                            </button>
                            <button class="btn" onclick="clearDrawing(${imageIndex})" style="background: #6c757d; color: white;">
                                üóëÔ∏è Clear All
                            </button>
                        </div>
                    </div>
                    
                    <div style="text-align: center; position: relative; display: inline-block; width: 100%;">
                        <div id="canvas-loading-${imageIndex}" style="
                            position: absolute; 
                            top: 50%; 
                            left: 50%; 
                            transform: translate(-50%, -50%);
                            background: rgba(255,255,255,0.9);
                            padding: 20px;
                            border-radius: 8px;
                            border: 2px solid #007bff;
                            z-index: 1000;
                        ">
                            <div style="font-size: 16px; color: #007bff; margin-bottom: 10px;">üì∏ Loading analysis result...</div>
                            <div style="width: 30px; height: 30px; border: 3px solid #f3f3f3; border-top: 3px solid #007bff; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                        </div>
                        <canvas id="drawing-canvas-${imageIndex}" 
                                style="border: 2px solid #007bff; border-radius: 8px; cursor: crosshair; max-width: 100%; display: block; margin: 0 auto;"
                                onmousedown="startDrawing(event, ${imageIndex})"
                                onmousemove="draw(event, ${imageIndex})"
                                onmouseup="stopDrawing(${imageIndex})"
                                onmouseleave="stopDrawing(${imageIndex})"
                                ontouchstart="handleTouch(event, ${imageIndex}, 'start')"
                                ontouchmove="handleTouch(event, ${imageIndex}, 'move')"
                                ontouchend="handleTouch(event, ${imageIndex}, 'end')">
                        </canvas>
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">
                            üí° <strong>Tip:</strong> You should see the original detection results with highlighted cells. 
                            Draw over correct detections in green, false positives in red, and missed cells in blue.
                        </p>
                        <button class="btn btn-warning" onclick="saveDrawingAnnotations(${imageIndex})">
                            üíæ Save Annotations for this Image
                        </button>
                    </div>
                </div>
            `;
            
            // Add CSS animation for loading spinner
            if (!document.getElementById('spinner-style')) {
                const style = document.createElement('style');
                style.id = 'spinner-style';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Load image onto canvas
            loadImageToCanvas(imageIndex, image);
        }

        function saveDrawingAnnotations(imageIndex) {
            if (!annotations[imageIndex]) {
                alert('No annotations to save');
                return;
            }
            
            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            if (!canvas) {
                alert('Canvas not found');
                return;
            }
            
            // Get the canvas image data
            const imageData = canvas.toDataURL('image/png');
            
            // Show saving indicator
            const saveBtn = document.querySelector(`#annotation-${imageIndex} .btn-warning`);
            const originalText = saveBtn ? saveBtn.innerHTML : '';
            if (saveBtn) {
                saveBtn.innerHTML = '‚è≥ Saving...';
                saveBtn.disabled = true;
            }
            
            const annotationData = {
                session_id: currentTrainingSession.id,
                image_index: imageIndex,
                image_filename: currentTrainingSession.images[imageIndex].filename,
                annotations: annotations[imageIndex],
                annotated_image: imageData
            };
            
            console.log(`üíæ Saving annotations for image ${imageIndex + 1}...`);
            
            fetch('/api/tophat/save_annotations', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(annotationData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`‚úÖ Annotations saved for image ${imageIndex + 1}`);
                    alert('Annotations saved successfully!');
                    if (saveBtn) {
                        saveBtn.innerHTML = '‚úÖ Annotations Saved';
                        saveBtn.className = 'btn btn-success';
                        saveBtn.disabled = true;
                    }
                } else {
                    console.error(`‚ùå Failed to save annotations for image ${imageIndex + 1}:`, data.error);
                    alert('Failed to save annotations: ' + data.error);
                    // Restore button
                    if (saveBtn) {
                        saveBtn.innerHTML = originalText;
                        saveBtn.disabled = false;
                    }
                }
            })
            .catch(error => {
                console.error('Annotation save error:', error);
                alert('Failed to save annotations: Network error');
                // Restore button
                if (saveBtn) {
                    saveBtn.innerHTML = originalText;
                    saveBtn.disabled = false;
                }
            });
        }

        function loadImageToCanvas(imageIndex, imageData) {
            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            const ctx = canvas.getContext('2d');
            const loadingIndicator = document.getElementById(`canvas-loading-${imageIndex}`);
            
            // Initialize drawing state first
            drawingState[imageIndex] = {
                isDrawing: false,
                mode: 'correct',
                lastX: 0,
                lastY: 0
            };
            
            annotations[imageIndex] = {
                correct: [],
                false_positive: [],
                missed: []
            };
            
            // Set default drawing mode to correct
            setTimeout(() => setDrawingMode(imageIndex, 'correct'), 100);
            
            // Create an image element to load the detection result
            const img = new Image();
            img.onload = function() {
                // Hide loading indicator
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
                
                // Set canvas size to match image (with max constraints)
                const maxWidth = 800;
                const maxHeight = 600;
                
                let canvasWidth = img.width;
                let canvasHeight = img.height;
                
                // Scale down if too large
                if (canvasWidth > maxWidth) {
                    const scale = maxWidth / canvasWidth;
                    canvasWidth = maxWidth;
                    canvasHeight = canvasHeight * scale;
                }
                
                if (canvasHeight > maxHeight) {
                    const scale = maxHeight / canvasHeight;
                    canvasHeight = maxHeight;
                    canvasWidth = canvasWidth * scale;
                }
                
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                
                // Draw the detection result image
                ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                
                console.log(`‚úÖ Loaded training image ${imageIndex + 1} onto canvas (${canvasWidth}x${canvasHeight})`);
            };
            
            img.onerror = function() {
                console.error(`‚ùå Failed to load training image ${imageIndex + 1}`);
                
                // Hide loading indicator and show error
                if (loadingIndicator) {
                    loadingIndicator.innerHTML = `
                        <div style="color: #dc3545; font-size: 16px;">‚ùå Image loading failed</div>
                        <div style="font-size: 14px; color: #666; margin-top: 10px;">You can still draw annotations</div>
                    `;
                    setTimeout(() => {
                        if (loadingIndicator) loadingIndicator.style.display = 'none';
                    }, 3000);
                }
                
                // Fallback to placeholder
                canvas.width = 600;
                canvas.height = 400;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#333';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Original image unavailable', canvas.width/2, canvas.height/2 - 10);
                ctx.fillText('Draw annotations here', canvas.width/2, canvas.height/2 + 10);
            };
            
            // Load the detection visualization from the analysis result
            if (imageData.image_data && imageData.image_data.visualizations && imageData.image_data.visualizations.detection_overview) {
                // Use the detection overview image from the analysis
                console.log(`üì∏ Loading detection visualization for image ${imageIndex + 1}...`);
                img.src = `data:image/png;base64,${imageData.image_data.visualizations.detection_overview}`;
            } else {
                // Fallback: try to load from the original image path
                console.log(`üîÑ No detection visualization found, trying original image for ${imageIndex + 1}...`);
                const imagePath = imageData.path;
                if (imagePath && imagePath.includes('uploads/')) {
                    const filename = imagePath.split('/').pop();
                    img.src = `/uploads/${filename}`;
                } else {
                    // Last resort: show placeholder and log error
                    console.warn(`‚ö†Ô∏è No image source available for image ${imageIndex + 1}`);
                    img.onerror();
                }
            }
        }

        // Touch support for mobile devices
        function handleTouch(event, imageIndex, phase) {
            event.preventDefault(); // Prevent scrolling
            
            if (!event.touches || event.touches.length === 0) return;
            
            const touch = event.touches[0];
            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            const rect = canvas.getBoundingClientRect();
            
            // Create a synthetic mouse event
            const mouseEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY,
                target: canvas
            };
            
            switch (phase) {
                case 'start':
                    startDrawing(mouseEvent, imageIndex);
                    break;
                case 'move':
                    draw(mouseEvent, imageIndex);
                    break;
                case 'end':
                    stopDrawing(imageIndex);
                    break;
            }
        }

        function setDrawingMode(imageIndex, mode) {
            if (!drawingState[imageIndex]) return;
            
            drawingState[imageIndex].mode = mode;
            
            // Update button styles with better visual feedback
            const buttons = {
                'correct': document.getElementById(`correct-btn-${imageIndex}`),
                'false_positive': document.getElementById(`false-btn-${imageIndex}`),
                'missed': document.getElementById(`missed-btn-${imageIndex}`)
            };
            
            // Reset all button styles
            Object.values(buttons).forEach(btn => {
                if (btn) {
                    btn.style.transform = 'scale(1)';
                    btn.style.boxShadow = 'none';
                    btn.style.border = '2px solid transparent';
                }
            });
            
            // Highlight selected button
            if (buttons[mode]) {
                buttons[mode].style.transform = 'scale(1.1)';
                buttons[mode].style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
                buttons[mode].style.border = '2px solid #fff';
            }
            
            // Update canvas cursor and border color based on mode
            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            const colors = {
                'correct': '#28a745',
                'false_positive': '#dc3545',
                'missed': '#007bff'
            };
            
            if (canvas) {
                canvas.style.borderColor = colors[mode];
                canvas.style.borderWidth = '3px';
                
                // Update cursor style
                canvas.style.cursor = 'crosshair';
            }
            
            console.log(`üé® Drawing mode set to: ${mode} for image ${imageIndex + 1}`);
        }

        function startDrawing(event, imageIndex) {
            if (!drawingState[imageIndex]) return;
            drawingState[imageIndex].isDrawing = true;
            const rect = event.target.getBoundingClientRect();
            drawingState[imageIndex].lastX = event.clientX - rect.left;
            drawingState[imageIndex].lastY = event.clientY - rect.top;
        }

        function draw(event, imageIndex) {
            if (!drawingState[imageIndex] || !drawingState[imageIndex].isDrawing) return;
            
            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            
            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;
            
            const colors = { 
                'correct': '#28a745', 
                'false_positive': '#dc3545', 
                'missed': '#007bff' 
            };
            
            ctx.strokeStyle = colors[drawingState[imageIndex].mode];
            ctx.lineWidth = 4; // Thicker line for better visibility
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = 0.8; // Slight transparency so we can see the image underneath
            
            ctx.beginPath();
            ctx.moveTo(drawingState[imageIndex].lastX, drawingState[imageIndex].lastY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            
            drawingState[imageIndex].lastX = currentX;
            drawingState[imageIndex].lastY = currentY;
        }

        function stopDrawing(imageIndex) {
            if (!drawingState[imageIndex]) return;
            drawingState[imageIndex].isDrawing = false;
        }

        function clearDrawing(imageIndex) {
            const canvas = document.getElementById(`drawing-canvas-${imageIndex}`);
            if (canvas) {
                // Clear annotations
                annotations[imageIndex] = { correct: [], false_positive: [], missed: [] };
                
                // Reload the original image
                const image = currentTrainingSession.images[imageIndex];
                loadImageToCanvas(imageIndex, image);
            }
        }

        function updateOverallProgress(completed, total) {
            const progressFill = document.getElementById('overall-progress-fill');
            const currentProgress = document.getElementById('current-progress');
            
            if (progressFill) {
                const percentage = (completed / total) * 100;
                progressFill.style.width = `${percentage}%`;
            }
            
            if (currentProgress) {
                currentProgress.textContent = completed;
            }
        }

        function exportResults(analysisId, format) {
            window.open(`/api/export/${analysisId}/${format}`, '_blank');
        }
    </script>
</body>
</html>